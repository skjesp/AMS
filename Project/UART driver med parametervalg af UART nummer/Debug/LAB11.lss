
LAB11.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800200  0000060a  0000067e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000060a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000006dc  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000070c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000a8  00000000  00000000  0000074c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000fbe  00000000  00000000  000007f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000cf1  00000000  00000000  000017b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000005fd  00000000  00000000  000024a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001e4  00000000  00000000  00002aa0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000062a  00000000  00000000  00002c84  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000003ab  00000000  00000000  000032ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  00003659  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  10:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  14:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  18:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  1c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  20:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  24:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  28:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  2c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  30:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  34:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  38:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  3c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  40:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  44:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  48:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  4c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  50:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  54:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  58:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  5c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  60:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  64:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  68:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  6c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  70:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  74:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  78:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  7c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  80:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  84:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  88:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  8c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  90:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  94:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  98:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  9c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  ac:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  bc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  cc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  dc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  e0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ea e0       	ldi	r30, 0x0A	; 10
  fc:	f6 e0       	ldi	r31, 0x06	; 6
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	ae 35       	cpi	r26, 0x5E	; 94
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
 10e:	0e 94 8d 00 	call	0x11a	; 0x11a <main>
 112:	0c 94 03 03 	jmp	0x606	; 0x606 <_exit>

00000116 <__bad_interrupt>:
 116:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011a <main>:

// Select the UART to test (UART0, UART1, UART2 or UART3)
#define myUART UART0

int main()
{	
 11a:	0f 93       	push	r16
 11c:	cf 93       	push	r28
 11e:	df 93       	push	r29
 120:	cd b7       	in	r28, 0x3d	; 61
 122:	de b7       	in	r29, 0x3e	; 62
 124:	a8 97       	sbiw	r28, 0x28	; 40
 126:	0f b6       	in	r0, 0x3f	; 63
 128:	f8 94       	cli
 12a:	de bf       	out	0x3e, r29	; 62
 12c:	0f be       	out	0x3f, r0	; 63
 12e:	cd bf       	out	0x3d, r28	; 61
  char tegn;
  char TestStreng[] = "This string is stored in SRAM memory\r\n";
 130:	87 e2       	ldi	r24, 0x27	; 39
 132:	e6 e3       	ldi	r30, 0x36	; 54
 134:	f2 e0       	ldi	r31, 0x02	; 2
 136:	de 01       	movw	r26, r28
 138:	12 96       	adiw	r26, 0x02	; 2
 13a:	01 90       	ld	r0, Z+
 13c:	0d 92       	st	X+, r0
 13e:	8a 95       	dec	r24
 140:	e1 f7       	brne	.-8      	; 0x13a <main+0x20>

  // Initialize LED port
  initLEDport();
 142:	0e 94 34 01 	call	0x268	; 0x268 <initLEDport>
  // Initialize UART
  // Important : Also other Baud Rates, Data Bits and Parity should be tested
  // Corresponding changes has to be made in the terminal program used
  // for the test
  InitUART(myUART, 9600, 8, 'N');
 146:	0e e4       	ldi	r16, 0x4E	; 78
 148:	28 e0       	ldi	r18, 0x08	; 8
 14a:	40 e8       	ldi	r20, 0x80	; 128
 14c:	55 e2       	ldi	r21, 0x25	; 37
 14e:	60 e0       	ldi	r22, 0x00	; 0
 150:	70 e0       	ldi	r23, 0x00	; 0
 152:	80 ec       	ldi	r24, 0xC0	; 192
 154:	90 e0       	ldi	r25, 0x00	; 0
 156:	0e 94 55 01 	call	0x2aa	; 0x2aa <InitUART>

  while (1)
  {
    // Testing SendChar
    writeAllLEDs(1);
 15a:	81 e0       	ldi	r24, 0x01	; 1
 15c:	0e 94 45 01 	call	0x28a	; 0x28a <writeAllLEDs>
    SendChar(myUART, 'A');
 160:	61 e4       	ldi	r22, 0x41	; 65
 162:	80 ec       	ldi	r24, 0xC0	; 192
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, 'B');
 16a:	62 e4       	ldi	r22, 0x42	; 66
 16c:	80 ec       	ldi	r24, 0xC0	; 192
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, 'C');
 174:	63 e4       	ldi	r22, 0x43	; 67
 176:	80 ec       	ldi	r24, 0xC0	; 192
 178:	90 e0       	ldi	r25, 0x00	; 0
 17a:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\r');
 17e:	6d e0       	ldi	r22, 0x0D	; 13
 180:	80 ec       	ldi	r24, 0xC0	; 192
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\n');
 188:	6a e0       	ldi	r22, 0x0A	; 10
 18a:	80 ec       	ldi	r24, 0xC0	; 192
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>

    // Testing ReadChar() : Read and echo
    writeAllLEDs(2);
 192:	82 e0       	ldi	r24, 0x02	; 2
 194:	0e 94 45 01 	call	0x28a	; 0x28a <writeAllLEDs>
    tegn = ReadChar(myUART);
 198:	80 ec       	ldi	r24, 0xC0	; 192
 19a:	90 e0       	ldi	r25, 0x00	; 0
 19c:	0e 94 17 02 	call	0x42e	; 0x42e <ReadChar>
 1a0:	89 83       	std	Y+1, r24	; 0x01
    SendChar(myUART, tegn);
 1a2:	69 81       	ldd	r22, Y+1	; 0x01
 1a4:	80 ec       	ldi	r24, 0xC0	; 192
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\r');
 1ac:	6d e0       	ldi	r22, 0x0D	; 13
 1ae:	80 ec       	ldi	r24, 0xC0	; 192
 1b0:	90 e0       	ldi	r25, 0x00	; 0
 1b2:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\n');
 1b6:	6a e0       	ldi	r22, 0x0A	; 10
 1b8:	80 ec       	ldi	r24, 0xC0	; 192
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>

    // Testing CharReady() : Wait, read and echo
    writeAllLEDs(3);	
 1c0:	83 e0       	ldi	r24, 0x03	; 3
 1c2:	0e 94 45 01 	call	0x28a	; 0x28a <writeAllLEDs>
    while ( !CharReady(myUART) )
 1c6:	00 00       	nop
 1c8:	80 ec       	ldi	r24, 0xC0	; 192
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	0e 94 05 02 	call	0x40a	; 0x40a <CharReady>
 1d0:	88 23       	and	r24, r24
 1d2:	d1 f3       	breq	.-12     	; 0x1c8 <main+0xae>
    {}
    SendChar(myUART, ReadChar(myUART) );
 1d4:	80 ec       	ldi	r24, 0xC0	; 192
 1d6:	90 e0       	ldi	r25, 0x00	; 0
 1d8:	0e 94 17 02 	call	0x42e	; 0x42e <ReadChar>
 1dc:	68 2f       	mov	r22, r24
 1de:	80 ec       	ldi	r24, 0xC0	; 192
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\r');
 1e6:	6d e0       	ldi	r22, 0x0D	; 13
 1e8:	80 ec       	ldi	r24, 0xC0	; 192
 1ea:	90 e0       	ldi	r25, 0x00	; 0
 1ec:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\n');
 1f0:	6a e0       	ldi	r22, 0x0A	; 10
 1f2:	80 ec       	ldi	r24, 0xC0	; 192
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>

    // Sending string stored in Flash (constant string)
    writeAllLEDs(4);
 1fa:	84 e0       	ldi	r24, 0x04	; 4
 1fc:	0e 94 45 01 	call	0x28a	; 0x28a <writeAllLEDs>
    SendString(myUART, "This string is stored as a constant in flash memory\r\n");
 200:	60 e0       	ldi	r22, 0x00	; 0
 202:	72 e0       	ldi	r23, 0x02	; 2
 204:	80 ec       	ldi	r24, 0xC0	; 192
 206:	90 e0       	ldi	r25, 0x00	; 0
 208:	0e 94 50 02 	call	0x4a0	; 0x4a0 <SendString>

    // Sending string stored in SRAM (modify-able string)
    writeAllLEDs(5);
 20c:	85 e0       	ldi	r24, 0x05	; 5
 20e:	0e 94 45 01 	call	0x28a	; 0x28a <writeAllLEDs>
    SendString(myUART, TestStreng);
 212:	ce 01       	movw	r24, r28
 214:	02 96       	adiw	r24, 0x02	; 2
 216:	bc 01       	movw	r22, r24
 218:	80 ec       	ldi	r24, 0xC0	; 192
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	0e 94 50 02 	call	0x4a0	; 0x4a0 <SendString>

    // Testing SendInteger()
    writeAllLEDs(6);
 220:	86 e0       	ldi	r24, 0x06	; 6
 222:	0e 94 45 01 	call	0x28a	; 0x28a <writeAllLEDs>
    SendInteger(myUART, 12345); //Positive number
 226:	69 e3       	ldi	r22, 0x39	; 57
 228:	70 e3       	ldi	r23, 0x30	; 48
 22a:	80 ec       	ldi	r24, 0xC0	; 192
 22c:	90 e0       	ldi	r25, 0x00	; 0
 22e:	0e 94 77 02 	call	0x4ee	; 0x4ee <SendInteger>
    SendChar(myUART, '\r');
 232:	6d e0       	ldi	r22, 0x0D	; 13
 234:	80 ec       	ldi	r24, 0xC0	; 192
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\n');
 23c:	6a e0       	ldi	r22, 0x0A	; 10
 23e:	80 ec       	ldi	r24, 0xC0	; 192
 240:	90 e0       	ldi	r25, 0x00	; 0
 242:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendInteger(myUART, -1000); //negative number
 246:	68 e1       	ldi	r22, 0x18	; 24
 248:	7c ef       	ldi	r23, 0xFC	; 252
 24a:	80 ec       	ldi	r24, 0xC0	; 192
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	0e 94 77 02 	call	0x4ee	; 0x4ee <SendInteger>
    SendChar(myUART, '\r');
 252:	6d e0       	ldi	r22, 0x0D	; 13
 254:	80 ec       	ldi	r24, 0xC0	; 192
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    SendChar(myUART, '\n');
 25c:	6a e0       	ldi	r22, 0x0A	; 10
 25e:	80 ec       	ldi	r24, 0xC0	; 192
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
  }
 266:	79 cf       	rjmp	.-270    	; 0x15a <main+0x40>

00000268 <initLEDport>:
**************************************************/
#include <avr/io.h>
#define MAX_LED_NR 7

void initLEDport()
{
 268:	cf 93       	push	r28
 26a:	df 93       	push	r29
 26c:	cd b7       	in	r28, 0x3d	; 61
 26e:	de b7       	in	r29, 0x3e	; 62
  // Sæt alle PORTB's ben til at være udgange
  DDRB = 0xFF;
 270:	84 e2       	ldi	r24, 0x24	; 36
 272:	90 e0       	ldi	r25, 0x00	; 0
 274:	2f ef       	ldi	r18, 0xFF	; 255
 276:	fc 01       	movw	r30, r24
 278:	20 83       	st	Z, r18
  // Sluk alle lysdioderne
  PORTB = 0;
 27a:	85 e2       	ldi	r24, 0x25	; 37
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	fc 01       	movw	r30, r24
 280:	10 82       	st	Z, r1
}
 282:	00 00       	nop
 284:	df 91       	pop	r29
 286:	cf 91       	pop	r28
 288:	08 95       	ret

0000028a <writeAllLEDs>:

void writeAllLEDs(unsigned char pattern)
{
 28a:	cf 93       	push	r28
 28c:	df 93       	push	r29
 28e:	1f 92       	push	r1
 290:	cd b7       	in	r28, 0x3d	; 61
 292:	de b7       	in	r29, 0x3e	; 62
 294:	89 83       	std	Y+1, r24	; 0x01
  // Hent parameteren og skriv til lysdioderne
  PORTB = pattern;   
 296:	85 e2       	ldi	r24, 0x25	; 37
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	29 81       	ldd	r18, Y+1	; 0x01
 29c:	fc 01       	movw	r30, r24
 29e:	20 83       	st	Z, r18
}
 2a0:	00 00       	nop
 2a2:	0f 90       	pop	r0
 2a4:	df 91       	pop	r29
 2a6:	cf 91       	pop	r28
 2a8:	08 95       	ret

000002aa <InitUART>:
	BaudRate: Wanted Baud Rate (300-115200).
	Databits: Wanted number of Data Bits (5-8).
	Parity: 'E' (Even parity), 'O' (Odd parity), otherwise No Parity.
*************************************************************************/
void InitUART(unsigned int UART_adr, unsigned long BaudRate, unsigned char DataBit, char Parity)
{
 2aa:	cf 92       	push	r12
 2ac:	df 92       	push	r13
 2ae:	ef 92       	push	r14
 2b0:	ff 92       	push	r15
 2b2:	0f 93       	push	r16
 2b4:	1f 93       	push	r17
 2b6:	cf 93       	push	r28
 2b8:	df 93       	push	r29
 2ba:	cd b7       	in	r28, 0x3d	; 61
 2bc:	de b7       	in	r29, 0x3e	; 62
 2be:	28 97       	sbiw	r28, 0x08	; 8
 2c0:	0f b6       	in	r0, 0x3f	; 63
 2c2:	f8 94       	cli
 2c4:	de bf       	out	0x3e, r29	; 62
 2c6:	0f be       	out	0x3f, r0	; 63
 2c8:	cd bf       	out	0x3d, r28	; 61
 2ca:	9a 83       	std	Y+2, r25	; 0x02
 2cc:	89 83       	std	Y+1, r24	; 0x01
 2ce:	4b 83       	std	Y+3, r20	; 0x03
 2d0:	5c 83       	std	Y+4, r21	; 0x04
 2d2:	6d 83       	std	Y+5, r22	; 0x05
 2d4:	7e 83       	std	Y+6, r23	; 0x06
 2d6:	2f 83       	std	Y+7, r18	; 0x07
 2d8:	08 87       	std	Y+8, r16	; 0x08
  if ((BaudRate >= 300) && (BaudRate <= 115200) && (DataBit >=5) && (DataBit <= 8))
 2da:	8b 81       	ldd	r24, Y+3	; 0x03
 2dc:	9c 81       	ldd	r25, Y+4	; 0x04
 2de:	ad 81       	ldd	r26, Y+5	; 0x05
 2e0:	be 81       	ldd	r27, Y+6	; 0x06
 2e2:	8c 32       	cpi	r24, 0x2C	; 44
 2e4:	91 40       	sbci	r25, 0x01	; 1
 2e6:	a1 05       	cpc	r26, r1
 2e8:	b1 05       	cpc	r27, r1
 2ea:	08 f4       	brcc	.+2      	; 0x2ee <InitUART+0x44>
 2ec:	7e c0       	rjmp	.+252    	; 0x3ea <InitUART+0x140>
 2ee:	8b 81       	ldd	r24, Y+3	; 0x03
 2f0:	9c 81       	ldd	r25, Y+4	; 0x04
 2f2:	ad 81       	ldd	r26, Y+5	; 0x05
 2f4:	be 81       	ldd	r27, Y+6	; 0x06
 2f6:	81 30       	cpi	r24, 0x01	; 1
 2f8:	92 4c       	sbci	r25, 0xC2	; 194
 2fa:	a1 40       	sbci	r26, 0x01	; 1
 2fc:	b1 05       	cpc	r27, r1
 2fe:	08 f0       	brcs	.+2      	; 0x302 <InitUART+0x58>
 300:	74 c0       	rjmp	.+232    	; 0x3ea <InitUART+0x140>
 302:	8f 81       	ldd	r24, Y+7	; 0x07
 304:	85 30       	cpi	r24, 0x05	; 5
 306:	08 f4       	brcc	.+2      	; 0x30a <InitUART+0x60>
 308:	70 c0       	rjmp	.+224    	; 0x3ea <InitUART+0x140>
 30a:	8f 81       	ldd	r24, Y+7	; 0x07
 30c:	89 30       	cpi	r24, 0x09	; 9
 30e:	08 f0       	brcs	.+2      	; 0x312 <InitUART+0x68>
 310:	6c c0       	rjmp	.+216    	; 0x3ea <InitUART+0x140>
  { 
    // "Normal" clock, no multiprocessor mode (= default)
    UCSRnA = 0b00100000;
 312:	89 81       	ldd	r24, Y+1	; 0x01
 314:	9a 81       	ldd	r25, Y+2	; 0x02
 316:	20 e2       	ldi	r18, 0x20	; 32
 318:	fc 01       	movw	r30, r24
 31a:	20 83       	st	Z, r18
    // No interrupts enabled
    // Receiver enabled
    // Transmitter enabled
    // No 9 bit operation
    UCSRnB = 0b00011000;	
 31c:	89 81       	ldd	r24, Y+1	; 0x01
 31e:	9a 81       	ldd	r25, Y+2	; 0x02
 320:	01 96       	adiw	r24, 0x01	; 1
 322:	28 e1       	ldi	r18, 0x18	; 24
 324:	fc 01       	movw	r30, r24
 326:	20 83       	st	Z, r18
    // Asynchronous operation, 1 stop bit
    // Bit 2 and bit 1 controls the number of data bits
    UCSRnC = (DataBit-5)<<1;
 328:	89 81       	ldd	r24, Y+1	; 0x01
 32a:	9a 81       	ldd	r25, Y+2	; 0x02
 32c:	02 96       	adiw	r24, 0x02	; 2
 32e:	2f 81       	ldd	r18, Y+7	; 0x07
 330:	25 50       	subi	r18, 0x05	; 5
 332:	22 0f       	add	r18, r18
 334:	fc 01       	movw	r30, r24
 336:	20 83       	st	Z, r18
	// Set parity bits (if parity used)
	if (Parity == 'E')
 338:	88 85       	ldd	r24, Y+8	; 0x08
 33a:	85 34       	cpi	r24, 0x45	; 69
 33c:	69 f4       	brne	.+26     	; 0x358 <InitUART+0xae>
      UCSRnC |= 0b00100000;
 33e:	89 81       	ldd	r24, Y+1	; 0x01
 340:	9a 81       	ldd	r25, Y+2	; 0x02
 342:	02 96       	adiw	r24, 0x02	; 2
 344:	9c 01       	movw	r18, r24
 346:	89 81       	ldd	r24, Y+1	; 0x01
 348:	9a 81       	ldd	r25, Y+2	; 0x02
 34a:	02 96       	adiw	r24, 0x02	; 2
 34c:	fc 01       	movw	r30, r24
 34e:	80 81       	ld	r24, Z
 350:	80 62       	ori	r24, 0x20	; 32
 352:	f9 01       	movw	r30, r18
 354:	80 83       	st	Z, r24
 356:	0f c0       	rjmp	.+30     	; 0x376 <InitUART+0xcc>
    else if (Parity == 'O')	  
 358:	88 85       	ldd	r24, Y+8	; 0x08
 35a:	8f 34       	cpi	r24, 0x4F	; 79
 35c:	61 f4       	brne	.+24     	; 0x376 <InitUART+0xcc>
      UCSRnC |= 0b00110000;	
 35e:	89 81       	ldd	r24, Y+1	; 0x01
 360:	9a 81       	ldd	r25, Y+2	; 0x02
 362:	02 96       	adiw	r24, 0x02	; 2
 364:	9c 01       	movw	r18, r24
 366:	89 81       	ldd	r24, Y+1	; 0x01
 368:	9a 81       	ldd	r25, Y+2	; 0x02
 36a:	02 96       	adiw	r24, 0x02	; 2
 36c:	fc 01       	movw	r30, r24
 36e:	80 81       	ld	r24, Z
 370:	80 63       	ori	r24, 0x30	; 48
 372:	f9 01       	movw	r30, r18
 374:	80 83       	st	Z, r24
    // Set Baud Rate according to the parameter BaudRate:
    // Adding (8*Baudrate) ensures correct rounding (up/down)
    UBRRn = (XTAL+(8*BaudRate))/(16*BaudRate) - 1;
 376:	89 81       	ldd	r24, Y+1	; 0x01
 378:	9a 81       	ldd	r25, Y+2	; 0x02
 37a:	04 96       	adiw	r24, 0x04	; 4
 37c:	8c 01       	movw	r16, r24
 37e:	8b 81       	ldd	r24, Y+3	; 0x03
 380:	9c 81       	ldd	r25, Y+4	; 0x04
 382:	ad 81       	ldd	r26, Y+5	; 0x05
 384:	be 81       	ldd	r27, Y+6	; 0x06
 386:	80 58       	subi	r24, 0x80	; 128
 388:	9b 47       	sbci	r25, 0x7B	; 123
 38a:	a1 4e       	sbci	r26, 0xE1	; 225
 38c:	bf 4f       	sbci	r27, 0xFF	; 255
 38e:	88 0f       	add	r24, r24
 390:	99 1f       	adc	r25, r25
 392:	aa 1f       	adc	r26, r26
 394:	bb 1f       	adc	r27, r27
 396:	88 0f       	add	r24, r24
 398:	99 1f       	adc	r25, r25
 39a:	aa 1f       	adc	r26, r26
 39c:	bb 1f       	adc	r27, r27
 39e:	88 0f       	add	r24, r24
 3a0:	99 1f       	adc	r25, r25
 3a2:	aa 1f       	adc	r26, r26
 3a4:	bb 1f       	adc	r27, r27
 3a6:	6c 01       	movw	r12, r24
 3a8:	7d 01       	movw	r14, r26
 3aa:	8b 81       	ldd	r24, Y+3	; 0x03
 3ac:	9c 81       	ldd	r25, Y+4	; 0x04
 3ae:	ad 81       	ldd	r26, Y+5	; 0x05
 3b0:	be 81       	ldd	r27, Y+6	; 0x06
 3b2:	88 0f       	add	r24, r24
 3b4:	99 1f       	adc	r25, r25
 3b6:	aa 1f       	adc	r26, r26
 3b8:	bb 1f       	adc	r27, r27
 3ba:	88 0f       	add	r24, r24
 3bc:	99 1f       	adc	r25, r25
 3be:	aa 1f       	adc	r26, r26
 3c0:	bb 1f       	adc	r27, r27
 3c2:	88 0f       	add	r24, r24
 3c4:	99 1f       	adc	r25, r25
 3c6:	aa 1f       	adc	r26, r26
 3c8:	bb 1f       	adc	r27, r27
 3ca:	88 0f       	add	r24, r24
 3cc:	99 1f       	adc	r25, r25
 3ce:	aa 1f       	adc	r26, r26
 3d0:	bb 1f       	adc	r27, r27
 3d2:	9c 01       	movw	r18, r24
 3d4:	ad 01       	movw	r20, r26
 3d6:	c7 01       	movw	r24, r14
 3d8:	b6 01       	movw	r22, r12
 3da:	0e 94 a1 02 	call	0x542	; 0x542 <__udivmodsi4>
 3de:	da 01       	movw	r26, r20
 3e0:	c9 01       	movw	r24, r18
 3e2:	01 97       	sbiw	r24, 0x01	; 1
 3e4:	f8 01       	movw	r30, r16
 3e6:	91 83       	std	Z+1, r25	; 0x01
 3e8:	80 83       	st	Z, r24
  }  
}
 3ea:	00 00       	nop
 3ec:	28 96       	adiw	r28, 0x08	; 8
 3ee:	0f b6       	in	r0, 0x3f	; 63
 3f0:	f8 94       	cli
 3f2:	de bf       	out	0x3e, r29	; 62
 3f4:	0f be       	out	0x3f, r0	; 63
 3f6:	cd bf       	out	0x3d, r28	; 61
 3f8:	df 91       	pop	r29
 3fa:	cf 91       	pop	r28
 3fc:	1f 91       	pop	r17
 3fe:	0f 91       	pop	r16
 400:	ff 90       	pop	r15
 402:	ef 90       	pop	r14
 404:	df 90       	pop	r13
 406:	cf 90       	pop	r12
 408:	08 95       	ret

0000040a <CharReady>:
/*************************************************************************
  Returns 0 (FALSE), if the UART has NOT received a new character.
  Returns value <> 0 (TRUE), if the UART HAS received a new character.
*************************************************************************/
unsigned char CharReady(unsigned int UART_adr)
{
 40a:	cf 93       	push	r28
 40c:	df 93       	push	r29
 40e:	1f 92       	push	r1
 410:	1f 92       	push	r1
 412:	cd b7       	in	r28, 0x3d	; 61
 414:	de b7       	in	r29, 0x3e	; 62
 416:	9a 83       	std	Y+2, r25	; 0x02
 418:	89 83       	std	Y+1, r24	; 0x01
   return UCSRnA & (1<<7);
 41a:	89 81       	ldd	r24, Y+1	; 0x01
 41c:	9a 81       	ldd	r25, Y+2	; 0x02
 41e:	fc 01       	movw	r30, r24
 420:	80 81       	ld	r24, Z
 422:	80 78       	andi	r24, 0x80	; 128
}
 424:	0f 90       	pop	r0
 426:	0f 90       	pop	r0
 428:	df 91       	pop	r29
 42a:	cf 91       	pop	r28
 42c:	08 95       	ret

0000042e <ReadChar>:
/*************************************************************************
Awaits new character received.
Then this character is returned.
*************************************************************************/
char ReadChar(unsigned int UART_adr)
{
 42e:	cf 93       	push	r28
 430:	df 93       	push	r29
 432:	1f 92       	push	r1
 434:	1f 92       	push	r1
 436:	cd b7       	in	r28, 0x3d	; 61
 438:	de b7       	in	r29, 0x3e	; 62
 43a:	9a 83       	std	Y+2, r25	; 0x02
 43c:	89 83       	std	Y+1, r24	; 0x01
  // Wait for new character received
  while ( (UCSRnA & (1<<7)) == 0 )
 43e:	00 00       	nop
 440:	89 81       	ldd	r24, Y+1	; 0x01
 442:	9a 81       	ldd	r25, Y+2	; 0x02
 444:	fc 01       	movw	r30, r24
 446:	80 81       	ld	r24, Z
 448:	88 23       	and	r24, r24
 44a:	d4 f7       	brge	.-12     	; 0x440 <ReadChar+0x12>
  {}                        
  // Then return it
  return UDRn;
 44c:	89 81       	ldd	r24, Y+1	; 0x01
 44e:	9a 81       	ldd	r25, Y+2	; 0x02
 450:	06 96       	adiw	r24, 0x06	; 6
 452:	fc 01       	movw	r30, r24
 454:	80 81       	ld	r24, Z
}
 456:	0f 90       	pop	r0
 458:	0f 90       	pop	r0
 45a:	df 91       	pop	r29
 45c:	cf 91       	pop	r28
 45e:	08 95       	ret

00000460 <SendChar>:
Then send the character.
Parameter :
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(unsigned int UART_adr, char Tegn)
{
 460:	cf 93       	push	r28
 462:	df 93       	push	r29
 464:	00 d0       	rcall	.+0      	; 0x466 <SendChar+0x6>
 466:	cd b7       	in	r28, 0x3d	; 61
 468:	de b7       	in	r29, 0x3e	; 62
 46a:	9a 83       	std	Y+2, r25	; 0x02
 46c:	89 83       	std	Y+1, r24	; 0x01
 46e:	6b 83       	std	Y+3, r22	; 0x03
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSRnA & (1<<5)) == 0 )
 470:	00 00       	nop
 472:	89 81       	ldd	r24, Y+1	; 0x01
 474:	9a 81       	ldd	r25, Y+2	; 0x02
 476:	fc 01       	movw	r30, r24
 478:	80 81       	ld	r24, Z
 47a:	88 2f       	mov	r24, r24
 47c:	90 e0       	ldi	r25, 0x00	; 0
 47e:	80 72       	andi	r24, 0x20	; 32
 480:	99 27       	eor	r25, r25
 482:	89 2b       	or	r24, r25
 484:	b1 f3       	breq	.-20     	; 0x472 <SendChar+0x12>
  {}
  // Then send the character
  UDRn = Tegn;
 486:	89 81       	ldd	r24, Y+1	; 0x01
 488:	9a 81       	ldd	r25, Y+2	; 0x02
 48a:	06 96       	adiw	r24, 0x06	; 6
 48c:	2b 81       	ldd	r18, Y+3	; 0x03
 48e:	fc 01       	movw	r30, r24
 490:	20 83       	st	Z, r18
}
 492:	00 00       	nop
 494:	0f 90       	pop	r0
 496:	0f 90       	pop	r0
 498:	0f 90       	pop	r0
 49a:	df 91       	pop	r29
 49c:	cf 91       	pop	r28
 49e:	08 95       	ret

000004a0 <SendString>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(unsigned int UART_adr, char* Streng)
{
 4a0:	cf 93       	push	r28
 4a2:	df 93       	push	r29
 4a4:	00 d0       	rcall	.+0      	; 0x4a6 <SendString+0x6>
 4a6:	1f 92       	push	r1
 4a8:	cd b7       	in	r28, 0x3d	; 61
 4aa:	de b7       	in	r29, 0x3e	; 62
 4ac:	9a 83       	std	Y+2, r25	; 0x02
 4ae:	89 83       	std	Y+1, r24	; 0x01
 4b0:	7c 83       	std	Y+4, r23	; 0x04
 4b2:	6b 83       	std	Y+3, r22	; 0x03
  // Repeat until zero-termination
  while (*Streng != 0)
 4b4:	0e c0       	rjmp	.+28     	; 0x4d2 <SendString+0x32>
  {
    // Send the character pointed to by "Streng"
    SendChar(UART_adr, *Streng);
 4b6:	8b 81       	ldd	r24, Y+3	; 0x03
 4b8:	9c 81       	ldd	r25, Y+4	; 0x04
 4ba:	fc 01       	movw	r30, r24
 4bc:	20 81       	ld	r18, Z
 4be:	89 81       	ldd	r24, Y+1	; 0x01
 4c0:	9a 81       	ldd	r25, Y+2	; 0x02
 4c2:	62 2f       	mov	r22, r18
 4c4:	0e 94 30 02 	call	0x460	; 0x460 <SendChar>
    // Advance the pointer one step
    Streng++;
 4c8:	8b 81       	ldd	r24, Y+3	; 0x03
 4ca:	9c 81       	ldd	r25, Y+4	; 0x04
 4cc:	01 96       	adiw	r24, 0x01	; 1
 4ce:	9c 83       	std	Y+4, r25	; 0x04
 4d0:	8b 83       	std	Y+3, r24	; 0x03
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(unsigned int UART_adr, char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
 4d2:	8b 81       	ldd	r24, Y+3	; 0x03
 4d4:	9c 81       	ldd	r25, Y+4	; 0x04
 4d6:	fc 01       	movw	r30, r24
 4d8:	80 81       	ld	r24, Z
 4da:	88 23       	and	r24, r24
 4dc:	61 f7       	brne	.-40     	; 0x4b6 <SendString+0x16>
    // Send the character pointed to by "Streng"
    SendChar(UART_adr, *Streng);
    // Advance the pointer one step
    Streng++;
  }
}
 4de:	00 00       	nop
 4e0:	0f 90       	pop	r0
 4e2:	0f 90       	pop	r0
 4e4:	0f 90       	pop	r0
 4e6:	0f 90       	pop	r0
 4e8:	df 91       	pop	r29
 4ea:	cf 91       	pop	r28
 4ec:	08 95       	ret

000004ee <SendInteger>:
Makes use of the C standard library <stdlib.h>.
Parameter:
    Tal: The integer to be converted and sent. 
*************************************************************************/
void SendInteger(unsigned int UART_adr, int Tal)
{
 4ee:	cf 93       	push	r28
 4f0:	df 93       	push	r29
 4f2:	cd b7       	in	r28, 0x3d	; 61
 4f4:	de b7       	in	r29, 0x3e	; 62
 4f6:	2b 97       	sbiw	r28, 0x0b	; 11
 4f8:	0f b6       	in	r0, 0x3f	; 63
 4fa:	f8 94       	cli
 4fc:	de bf       	out	0x3e, r29	; 62
 4fe:	0f be       	out	0x3f, r0	; 63
 500:	cd bf       	out	0x3d, r28	; 61
 502:	99 87       	std	Y+9, r25	; 0x09
 504:	88 87       	std	Y+8, r24	; 0x08
 506:	7b 87       	std	Y+11, r23	; 0x0b
 508:	6a 87       	std	Y+10, r22	; 0x0a
char array[7];
  // Convert the integer to an ASCII string (array), radix = 10 
  itoa(Tal, array, 10);
 50a:	8a 85       	ldd	r24, Y+10	; 0x0a
 50c:	9b 85       	ldd	r25, Y+11	; 0x0b
 50e:	4a e0       	ldi	r20, 0x0A	; 10
 510:	50 e0       	ldi	r21, 0x00	; 0
 512:	9e 01       	movw	r18, r28
 514:	2f 5f       	subi	r18, 0xFF	; 255
 516:	3f 4f       	sbci	r19, 0xFF	; 255
 518:	b9 01       	movw	r22, r18
 51a:	0e 94 c3 02 	call	0x586	; 0x586 <itoa>
  // - then send the string
  SendString(UART_adr, array);
 51e:	88 85       	ldd	r24, Y+8	; 0x08
 520:	99 85       	ldd	r25, Y+9	; 0x09
 522:	9e 01       	movw	r18, r28
 524:	2f 5f       	subi	r18, 0xFF	; 255
 526:	3f 4f       	sbci	r19, 0xFF	; 255
 528:	b9 01       	movw	r22, r18
 52a:	0e 94 50 02 	call	0x4a0	; 0x4a0 <SendString>
}
 52e:	00 00       	nop
 530:	2b 96       	adiw	r28, 0x0b	; 11
 532:	0f b6       	in	r0, 0x3f	; 63
 534:	f8 94       	cli
 536:	de bf       	out	0x3e, r29	; 62
 538:	0f be       	out	0x3f, r0	; 63
 53a:	cd bf       	out	0x3d, r28	; 61
 53c:	df 91       	pop	r29
 53e:	cf 91       	pop	r28
 540:	08 95       	ret

00000542 <__udivmodsi4>:
 542:	a1 e2       	ldi	r26, 0x21	; 33
 544:	1a 2e       	mov	r1, r26
 546:	aa 1b       	sub	r26, r26
 548:	bb 1b       	sub	r27, r27
 54a:	fd 01       	movw	r30, r26
 54c:	0d c0       	rjmp	.+26     	; 0x568 <__udivmodsi4_ep>

0000054e <__udivmodsi4_loop>:
 54e:	aa 1f       	adc	r26, r26
 550:	bb 1f       	adc	r27, r27
 552:	ee 1f       	adc	r30, r30
 554:	ff 1f       	adc	r31, r31
 556:	a2 17       	cp	r26, r18
 558:	b3 07       	cpc	r27, r19
 55a:	e4 07       	cpc	r30, r20
 55c:	f5 07       	cpc	r31, r21
 55e:	20 f0       	brcs	.+8      	; 0x568 <__udivmodsi4_ep>
 560:	a2 1b       	sub	r26, r18
 562:	b3 0b       	sbc	r27, r19
 564:	e4 0b       	sbc	r30, r20
 566:	f5 0b       	sbc	r31, r21

00000568 <__udivmodsi4_ep>:
 568:	66 1f       	adc	r22, r22
 56a:	77 1f       	adc	r23, r23
 56c:	88 1f       	adc	r24, r24
 56e:	99 1f       	adc	r25, r25
 570:	1a 94       	dec	r1
 572:	69 f7       	brne	.-38     	; 0x54e <__udivmodsi4_loop>
 574:	60 95       	com	r22
 576:	70 95       	com	r23
 578:	80 95       	com	r24
 57a:	90 95       	com	r25
 57c:	9b 01       	movw	r18, r22
 57e:	ac 01       	movw	r20, r24
 580:	bd 01       	movw	r22, r26
 582:	cf 01       	movw	r24, r30
 584:	08 95       	ret

00000586 <itoa>:
 586:	45 32       	cpi	r20, 0x25	; 37
 588:	51 05       	cpc	r21, r1
 58a:	20 f4       	brcc	.+8      	; 0x594 <itoa+0xe>
 58c:	42 30       	cpi	r20, 0x02	; 2
 58e:	10 f0       	brcs	.+4      	; 0x594 <itoa+0xe>
 590:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__itoa_ncheck>
 594:	fb 01       	movw	r30, r22
 596:	10 82       	st	Z, r1
 598:	cb 01       	movw	r24, r22
 59a:	08 95       	ret

0000059c <__itoa_ncheck>:
 59c:	bb 27       	eor	r27, r27
 59e:	4a 30       	cpi	r20, 0x0A	; 10
 5a0:	31 f4       	brne	.+12     	; 0x5ae <__itoa_ncheck+0x12>
 5a2:	99 23       	and	r25, r25
 5a4:	22 f4       	brpl	.+8      	; 0x5ae <__itoa_ncheck+0x12>
 5a6:	bd e2       	ldi	r27, 0x2D	; 45
 5a8:	90 95       	com	r25
 5aa:	81 95       	neg	r24
 5ac:	9f 4f       	sbci	r25, 0xFF	; 255
 5ae:	0c 94 da 02 	jmp	0x5b4	; 0x5b4 <__utoa_common>

000005b2 <__utoa_ncheck>:
 5b2:	bb 27       	eor	r27, r27

000005b4 <__utoa_common>:
 5b4:	fb 01       	movw	r30, r22
 5b6:	55 27       	eor	r21, r21
 5b8:	aa 27       	eor	r26, r26
 5ba:	88 0f       	add	r24, r24
 5bc:	99 1f       	adc	r25, r25
 5be:	aa 1f       	adc	r26, r26
 5c0:	a4 17       	cp	r26, r20
 5c2:	10 f0       	brcs	.+4      	; 0x5c8 <__utoa_common+0x14>
 5c4:	a4 1b       	sub	r26, r20
 5c6:	83 95       	inc	r24
 5c8:	50 51       	subi	r21, 0x10	; 16
 5ca:	b9 f7       	brne	.-18     	; 0x5ba <__utoa_common+0x6>
 5cc:	a0 5d       	subi	r26, 0xD0	; 208
 5ce:	aa 33       	cpi	r26, 0x3A	; 58
 5d0:	08 f0       	brcs	.+2      	; 0x5d4 <__utoa_common+0x20>
 5d2:	a9 5d       	subi	r26, 0xD9	; 217
 5d4:	a1 93       	st	Z+, r26
 5d6:	00 97       	sbiw	r24, 0x00	; 0
 5d8:	79 f7       	brne	.-34     	; 0x5b8 <__utoa_common+0x4>
 5da:	b1 11       	cpse	r27, r1
 5dc:	b1 93       	st	Z+, r27
 5de:	11 92       	st	Z+, r1
 5e0:	cb 01       	movw	r24, r22
 5e2:	0c 94 f3 02 	jmp	0x5e6	; 0x5e6 <strrev>

000005e6 <strrev>:
 5e6:	dc 01       	movw	r26, r24
 5e8:	fc 01       	movw	r30, r24
 5ea:	67 2f       	mov	r22, r23
 5ec:	71 91       	ld	r23, Z+
 5ee:	77 23       	and	r23, r23
 5f0:	e1 f7       	brne	.-8      	; 0x5ea <strrev+0x4>
 5f2:	32 97       	sbiw	r30, 0x02	; 2
 5f4:	04 c0       	rjmp	.+8      	; 0x5fe <strrev+0x18>
 5f6:	7c 91       	ld	r23, X
 5f8:	6d 93       	st	X+, r22
 5fa:	70 83       	st	Z, r23
 5fc:	62 91       	ld	r22, -Z
 5fe:	ae 17       	cp	r26, r30
 600:	bf 07       	cpc	r27, r31
 602:	c8 f3       	brcs	.-14     	; 0x5f6 <strrev+0x10>
 604:	08 95       	ret

00000606 <_exit>:
 606:	f8 94       	cli

00000608 <__stop_program>:
 608:	ff cf       	rjmp	.-2      	; 0x608 <__stop_program>
