
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800200  00000cec  00000d80  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000613  00800212  00800212  00000d92  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d92  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000dc4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e0  00000000  00000000  00000e04  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000025bc  00000000  00000000  00000fe4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000012f2  00000000  00000000  000035a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001188  00000000  00000000  00004892  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000454  00000000  00000000  00005a1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000dd4  00000000  00000000  00005e70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000011e4  00000000  00000000  00006c44  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c8  00000000  00000000  00007e28  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	8e c0       	rjmp	.+284    	; 0x122 <__bad_interrupt>
   6:	00 00       	nop
   8:	8c c0       	rjmp	.+280    	; 0x122 <__bad_interrupt>
   a:	00 00       	nop
   c:	8a c0       	rjmp	.+276    	; 0x122 <__bad_interrupt>
   e:	00 00       	nop
  10:	88 c0       	rjmp	.+272    	; 0x122 <__bad_interrupt>
  12:	00 00       	nop
  14:	86 c0       	rjmp	.+268    	; 0x122 <__bad_interrupt>
  16:	00 00       	nop
  18:	84 c0       	rjmp	.+264    	; 0x122 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	82 c0       	rjmp	.+260    	; 0x122 <__bad_interrupt>
  1e:	00 00       	nop
  20:	80 c0       	rjmp	.+256    	; 0x122 <__bad_interrupt>
  22:	00 00       	nop
  24:	7e c0       	rjmp	.+252    	; 0x122 <__bad_interrupt>
  26:	00 00       	nop
  28:	7c c0       	rjmp	.+248    	; 0x122 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	7a c0       	rjmp	.+244    	; 0x122 <__bad_interrupt>
  2e:	00 00       	nop
  30:	78 c0       	rjmp	.+240    	; 0x122 <__bad_interrupt>
  32:	00 00       	nop
  34:	76 c0       	rjmp	.+236    	; 0x122 <__bad_interrupt>
  36:	00 00       	nop
  38:	74 c0       	rjmp	.+232    	; 0x122 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	72 c0       	rjmp	.+228    	; 0x122 <__bad_interrupt>
  3e:	00 00       	nop
  40:	70 c0       	rjmp	.+224    	; 0x122 <__bad_interrupt>
  42:	00 00       	nop
  44:	6e c0       	rjmp	.+220    	; 0x122 <__bad_interrupt>
  46:	00 00       	nop
  48:	6c c0       	rjmp	.+216    	; 0x122 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	6a c0       	rjmp	.+212    	; 0x122 <__bad_interrupt>
  4e:	00 00       	nop
  50:	68 c0       	rjmp	.+208    	; 0x122 <__bad_interrupt>
  52:	00 00       	nop
  54:	66 c0       	rjmp	.+204    	; 0x122 <__bad_interrupt>
  56:	00 00       	nop
  58:	64 c0       	rjmp	.+200    	; 0x122 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	62 c0       	rjmp	.+196    	; 0x122 <__bad_interrupt>
  5e:	00 00       	nop
  60:	60 c0       	rjmp	.+192    	; 0x122 <__bad_interrupt>
  62:	00 00       	nop
  64:	5e c0       	rjmp	.+188    	; 0x122 <__bad_interrupt>
  66:	00 00       	nop
  68:	5c c0       	rjmp	.+184    	; 0x122 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	5a c0       	rjmp	.+180    	; 0x122 <__bad_interrupt>
  6e:	00 00       	nop
  70:	58 c0       	rjmp	.+176    	; 0x122 <__bad_interrupt>
  72:	00 00       	nop
  74:	56 c0       	rjmp	.+172    	; 0x122 <__bad_interrupt>
  76:	00 00       	nop
  78:	54 c0       	rjmp	.+168    	; 0x122 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	52 c0       	rjmp	.+164    	; 0x122 <__bad_interrupt>
  7e:	00 00       	nop
  80:	50 c0       	rjmp	.+160    	; 0x122 <__bad_interrupt>
  82:	00 00       	nop
  84:	4e c0       	rjmp	.+156    	; 0x122 <__bad_interrupt>
  86:	00 00       	nop
  88:	4c c0       	rjmp	.+152    	; 0x122 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	4a c0       	rjmp	.+148    	; 0x122 <__bad_interrupt>
  8e:	00 00       	nop
  90:	48 c0       	rjmp	.+144    	; 0x122 <__bad_interrupt>
  92:	00 00       	nop
  94:	46 c0       	rjmp	.+140    	; 0x122 <__bad_interrupt>
  96:	00 00       	nop
  98:	44 c0       	rjmp	.+136    	; 0x122 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	42 c0       	rjmp	.+132    	; 0x122 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	40 c0       	rjmp	.+128    	; 0x122 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	3e c0       	rjmp	.+124    	; 0x122 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	3c c0       	rjmp	.+120    	; 0x122 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	3a c0       	rjmp	.+116    	; 0x122 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	38 c0       	rjmp	.+112    	; 0x122 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	36 c0       	rjmp	.+108    	; 0x122 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	34 c0       	rjmp	.+104    	; 0x122 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	8f c2       	rjmp	.+1310   	; 0x5dc <__vector_47>
  be:	00 00       	nop
  c0:	30 c0       	rjmp	.+96     	; 0x122 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	2e c0       	rjmp	.+92     	; 0x122 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	2c c0       	rjmp	.+88     	; 0x122 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	2a c0       	rjmp	.+84     	; 0x122 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	28 c0       	rjmp	.+80     	; 0x122 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	26 c0       	rjmp	.+76     	; 0x122 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	24 c0       	rjmp	.+72     	; 0x122 <__bad_interrupt>
  da:	00 00       	nop
  dc:	22 c0       	rjmp	.+68     	; 0x122 <__bad_interrupt>
  de:	00 00       	nop
  e0:	20 c0       	rjmp	.+64     	; 0x122 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ec ee       	ldi	r30, 0xEC	; 236
  fc:	fc e0       	ldi	r31, 0x0C	; 12
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a2 31       	cpi	r26, 0x12	; 18
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	28 e0       	ldi	r18, 0x08	; 8
 110:	a2 e1       	ldi	r26, 0x12	; 18
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a5 32       	cpi	r26, 0x25	; 37
 11a:	b2 07       	cpc	r27, r18
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	37 d0       	rcall	.+110    	; 0x18e <main>
 120:	e3 c5       	rjmp	.+3014   	; 0xce8 <_exit>

00000122 <__bad_interrupt>:
 122:	6e cf       	rjmp	.-292    	; 0x0 <__vectors>

00000124 <initLEDport>:
  if (led_nr <= MAX_LED_NR)
  {
	// Dan (inverteret) maske på basis af parameteren (led_nr)
    mask = ~(0b00000001 << led_nr);
    // Sluk den aktuelle lysdiode (de andre ændres ikke)
    PORTB = PINB & mask;
 124:	8f ef       	ldi	r24, 0xFF	; 255
 126:	84 b9       	out	0x04, r24	; 4
 128:	15 b8       	out	0x05, r1	; 5
 12a:	08 95       	ret

0000012c <toggleLED>:
void toggleLED(unsigned char led_nr)
{
  // Lokal variabel
  unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
 12c:	88 30       	cpi	r24, 0x08	; 8
 12e:	60 f4       	brcc	.+24     	; 0x148 <toggleLED+0x1c>
  {
    // Dan maske på basis af parameteren (led_nr)
    mask = 0b00000001 << led_nr;
    // Toggle den aktuelle lysdiode (de andre ændres ikke)
    PORTB = PINB ^ mask;
 130:	43 b1       	in	r20, 0x03	; 3
 132:	21 e0       	ldi	r18, 0x01	; 1
 134:	30 e0       	ldi	r19, 0x00	; 0
 136:	b9 01       	movw	r22, r18
 138:	02 c0       	rjmp	.+4      	; 0x13e <toggleLED+0x12>
 13a:	66 0f       	add	r22, r22
 13c:	77 1f       	adc	r23, r23
 13e:	8a 95       	dec	r24
 140:	e2 f7       	brpl	.-8      	; 0x13a <toggleLED+0xe>
 142:	cb 01       	movw	r24, r22
 144:	84 27       	eor	r24, r20
 146:	85 b9       	out	0x05, r24	; 5
 148:	08 95       	ret

0000014a <vLEDFlashTask1>:
#include "FreeRTOS.h"
#include "task.h"
#include "led.h"

void vLEDFlashTask1( void *pvParameters )
{
 14a:	cf 93       	push	r28
 14c:	df 93       	push	r29
 14e:	1f 92       	push	r1
 150:	1f 92       	push	r1
 152:	cd b7       	in	r28, 0x3d	; 61
 154:	de b7       	in	r29, 0x3e	; 62
portTickType xLastWakeTime;
xLastWakeTime=xTaskGetTickCount();
 156:	b5 d3       	rcall	.+1898   	; 0x8c2 <xTaskGetTickCount>
 158:	9a 83       	std	Y+2, r25	; 0x02
 15a:	89 83       	std	Y+1, r24	; 0x01
  while(1)
  {
    toggleLED(0);
 15c:	80 e0       	ldi	r24, 0x00	; 0
 15e:	e6 df       	rcall	.-52     	; 0x12c <toggleLED>
    vTaskDelayUntil(&xLastWakeTime,1000);
 160:	68 ee       	ldi	r22, 0xE8	; 232
 162:	73 e0       	ldi	r23, 0x03	; 3
 164:	ce 01       	movw	r24, r28
 166:	01 96       	adiw	r24, 0x01	; 1
 168:	f8 d4       	rcall	.+2544   	; 0xb5a <vTaskDelayUntil>
 16a:	f8 cf       	rjmp	.-16     	; 0x15c <vLEDFlashTask1+0x12>

0000016c <vLEDFlashTask2>:
  }
}

void vLEDFlashTask2( void *pvParameters )
{
 16c:	cf 93       	push	r28
 16e:	df 93       	push	r29
 170:	1f 92       	push	r1
 172:	1f 92       	push	r1
 174:	cd b7       	in	r28, 0x3d	; 61
 176:	de b7       	in	r29, 0x3e	; 62
portTickType xLastWakeTime;
xLastWakeTime=xTaskGetTickCount();
 178:	a4 d3       	rcall	.+1864   	; 0x8c2 <xTaskGetTickCount>
 17a:	9a 83       	std	Y+2, r25	; 0x02
 17c:	89 83       	std	Y+1, r24	; 0x01
  while(1)
  {
    toggleLED(1);
 17e:	81 e0       	ldi	r24, 0x01	; 1
 180:	d5 df       	rcall	.-86     	; 0x12c <toggleLED>
    vTaskDelayUntil(&xLastWakeTime,500);
 182:	64 ef       	ldi	r22, 0xF4	; 244
 184:	71 e0       	ldi	r23, 0x01	; 1
 186:	ce 01       	movw	r24, r28
 188:	01 96       	adiw	r24, 0x01	; 1
 18a:	e7 d4       	rcall	.+2510   	; 0xb5a <vTaskDelayUntil>
 18c:	f8 cf       	rjmp	.-16     	; 0x17e <vLEDFlashTask2+0x12>

0000018e <main>:
  }
}

int main(void)
{
  initLEDport();
 18e:	ca df       	rcall	.-108    	; 0x124 <initLEDport>
  xTaskCreate( vLEDFlashTask1, ( signed char * ) "LED1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 190:	a1 2c       	mov	r10, r1
 192:	b1 2c       	mov	r11, r1
 194:	c1 2c       	mov	r12, r1
 196:	d1 2c       	mov	r13, r1
 198:	e1 2c       	mov	r14, r1
 19a:	f1 2c       	mov	r15, r1
 19c:	00 e0       	ldi	r16, 0x00	; 0
 19e:	20 e0       	ldi	r18, 0x00	; 0
 1a0:	30 e0       	ldi	r19, 0x00	; 0
 1a2:	45 e5       	ldi	r20, 0x55	; 85
 1a4:	50 e0       	ldi	r21, 0x00	; 0
 1a6:	62 e0       	ldi	r22, 0x02	; 2
 1a8:	72 e0       	ldi	r23, 0x02	; 2
 1aa:	85 ea       	ldi	r24, 0xA5	; 165
 1ac:	90 e0       	ldi	r25, 0x00	; 0
 1ae:	79 d2       	rcall	.+1266   	; 0x6a2 <xTaskGenericCreate>
  xTaskCreate( vLEDFlashTask2, ( signed char * ) "LED2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );	
 1b0:	20 e0       	ldi	r18, 0x00	; 0
 1b2:	30 e0       	ldi	r19, 0x00	; 0
 1b4:	45 e5       	ldi	r20, 0x55	; 85
 1b6:	50 e0       	ldi	r21, 0x00	; 0
 1b8:	67 e0       	ldi	r22, 0x07	; 7
 1ba:	72 e0       	ldi	r23, 0x02	; 2
 1bc:	86 eb       	ldi	r24, 0xB6	; 182
 1be:	90 e0       	ldi	r25, 0x00	; 0
  vTaskStartScheduler();
 1c0:	70 d2       	rcall	.+1248   	; 0x6a2 <xTaskGenericCreate>
 1c2:	50 d3       	rcall	.+1696   	; 0x864 <vTaskStartScheduler>
 1c4:	ff cf       	rjmp	.-2      	; 0x1c4 <main+0x36>

000001c6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 1c6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 1c8:	03 96       	adiw	r24, 0x03	; 3
 1ca:	92 83       	std	Z+2, r25	; 0x02
 1cc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 1ce:	2f ef       	ldi	r18, 0xFF	; 255
 1d0:	3f ef       	ldi	r19, 0xFF	; 255
 1d2:	34 83       	std	Z+4, r19	; 0x04
 1d4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 1d6:	96 83       	std	Z+6, r25	; 0x06
 1d8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 1da:	90 87       	std	Z+8, r25	; 0x08
 1dc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 1de:	10 82       	st	Z, r1
 1e0:	08 95       	ret

000001e2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 1e2:	fc 01       	movw	r30, r24
 1e4:	11 86       	std	Z+9, r1	; 0x09
 1e6:	10 86       	std	Z+8, r1	; 0x08
 1e8:	08 95       	ret

000001ea <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 1ea:	cf 93       	push	r28
 1ec:	df 93       	push	r29
 1ee:	fc 01       	movw	r30, r24
 1f0:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 1f2:	21 81       	ldd	r18, Z+1	; 0x01
 1f4:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 1f6:	e9 01       	movw	r28, r18
 1f8:	8a 81       	ldd	r24, Y+2	; 0x02
 1fa:	9b 81       	ldd	r25, Y+3	; 0x03
 1fc:	13 96       	adiw	r26, 0x03	; 3
 1fe:	9c 93       	st	X, r25
 200:	8e 93       	st	-X, r24
 202:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 204:	81 81       	ldd	r24, Z+1	; 0x01
 206:	92 81       	ldd	r25, Z+2	; 0x02
 208:	15 96       	adiw	r26, 0x05	; 5
 20a:	9c 93       	st	X, r25
 20c:	8e 93       	st	-X, r24
 20e:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 210:	8a 81       	ldd	r24, Y+2	; 0x02
 212:	9b 81       	ldd	r25, Y+3	; 0x03
 214:	ec 01       	movw	r28, r24
 216:	7d 83       	std	Y+5, r23	; 0x05
 218:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 21a:	e9 01       	movw	r28, r18
 21c:	7b 83       	std	Y+3, r23	; 0x03
 21e:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 220:	72 83       	std	Z+2, r23	; 0x02
 222:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 224:	19 96       	adiw	r26, 0x09	; 9
 226:	fc 93       	st	X, r31
 228:	ee 93       	st	-X, r30
 22a:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 22c:	80 81       	ld	r24, Z
 22e:	8f 5f       	subi	r24, 0xFF	; 255
 230:	80 83       	st	Z, r24
}
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	08 95       	ret

00000238 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 238:	cf 93       	push	r28
 23a:	df 93       	push	r29
 23c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 23e:	48 81       	ld	r20, Y
 240:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 242:	4f 3f       	cpi	r20, 0xFF	; 255
 244:	2f ef       	ldi	r18, 0xFF	; 255
 246:	52 07       	cpc	r21, r18
 248:	31 f4       	brne	.+12     	; 0x256 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 24a:	dc 01       	movw	r26, r24
 24c:	17 96       	adiw	r26, 0x07	; 7
 24e:	ed 91       	ld	r30, X+
 250:	fc 91       	ld	r31, X
 252:	18 97       	sbiw	r26, 0x08	; 8
 254:	17 c0       	rjmp	.+46     	; 0x284 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 256:	fc 01       	movw	r30, r24
 258:	33 96       	adiw	r30, 0x03	; 3
 25a:	dc 01       	movw	r26, r24
 25c:	15 96       	adiw	r26, 0x05	; 5
 25e:	2d 91       	ld	r18, X+
 260:	3c 91       	ld	r19, X
 262:	16 97       	sbiw	r26, 0x06	; 6
 264:	d9 01       	movw	r26, r18
 266:	2d 91       	ld	r18, X+
 268:	3c 91       	ld	r19, X
 26a:	42 17       	cp	r20, r18
 26c:	53 07       	cpc	r21, r19
 26e:	50 f0       	brcs	.+20     	; 0x284 <vListInsert+0x4c>
 270:	02 80       	ldd	r0, Z+2	; 0x02
 272:	f3 81       	ldd	r31, Z+3	; 0x03
 274:	e0 2d       	mov	r30, r0
 276:	a2 81       	ldd	r26, Z+2	; 0x02
 278:	b3 81       	ldd	r27, Z+3	; 0x03
 27a:	2d 91       	ld	r18, X+
 27c:	3c 91       	ld	r19, X
 27e:	42 17       	cp	r20, r18
 280:	53 07       	cpc	r21, r19
 282:	b0 f7       	brcc	.-20     	; 0x270 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 284:	a2 81       	ldd	r26, Z+2	; 0x02
 286:	b3 81       	ldd	r27, Z+3	; 0x03
 288:	bb 83       	std	Y+3, r27	; 0x03
 28a:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 28c:	15 96       	adiw	r26, 0x05	; 5
 28e:	dc 93       	st	X, r29
 290:	ce 93       	st	-X, r28
 292:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 294:	fd 83       	std	Y+5, r31	; 0x05
 296:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 298:	d3 83       	std	Z+3, r29	; 0x03
 29a:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 29c:	99 87       	std	Y+9, r25	; 0x09
 29e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 2a0:	fc 01       	movw	r30, r24
 2a2:	20 81       	ld	r18, Z
 2a4:	2f 5f       	subi	r18, 0xFF	; 255
 2a6:	20 83       	st	Z, r18
}
 2a8:	df 91       	pop	r29
 2aa:	cf 91       	pop	r28
 2ac:	08 95       	ret

000002ae <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 2ae:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 2b0:	a2 81       	ldd	r26, Z+2	; 0x02
 2b2:	b3 81       	ldd	r27, Z+3	; 0x03
 2b4:	84 81       	ldd	r24, Z+4	; 0x04
 2b6:	95 81       	ldd	r25, Z+5	; 0x05
 2b8:	15 96       	adiw	r26, 0x05	; 5
 2ba:	9c 93       	st	X, r25
 2bc:	8e 93       	st	-X, r24
 2be:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 2c0:	a4 81       	ldd	r26, Z+4	; 0x04
 2c2:	b5 81       	ldd	r27, Z+5	; 0x05
 2c4:	82 81       	ldd	r24, Z+2	; 0x02
 2c6:	93 81       	ldd	r25, Z+3	; 0x03
 2c8:	13 96       	adiw	r26, 0x03	; 3
 2ca:	9c 93       	st	X, r25
 2cc:	8e 93       	st	-X, r24
 2ce:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 2d0:	a0 85       	ldd	r26, Z+8	; 0x08
 2d2:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 2d4:	11 96       	adiw	r26, 0x01	; 1
 2d6:	8d 91       	ld	r24, X+
 2d8:	9c 91       	ld	r25, X
 2da:	12 97       	sbiw	r26, 0x02	; 2
 2dc:	e8 17       	cp	r30, r24
 2de:	f9 07       	cpc	r31, r25
 2e0:	31 f4       	brne	.+12     	; 0x2ee <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 2e2:	84 81       	ldd	r24, Z+4	; 0x04
 2e4:	95 81       	ldd	r25, Z+5	; 0x05
 2e6:	12 96       	adiw	r26, 0x02	; 2
 2e8:	9c 93       	st	X, r25
 2ea:	8e 93       	st	-X, r24
 2ec:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 2ee:	11 86       	std	Z+9, r1	; 0x09
 2f0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 2f2:	8c 91       	ld	r24, X
 2f4:	81 50       	subi	r24, 0x01	; 1
 2f6:	8c 93       	st	X, r24
 2f8:	08 95       	ret

000002fa <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 2fa:	31 e1       	ldi	r19, 0x11	; 17
 2fc:	fc 01       	movw	r30, r24
 2fe:	30 83       	st	Z, r19
 300:	31 97       	sbiw	r30, 0x01	; 1
 302:	22 e2       	ldi	r18, 0x22	; 34
 304:	20 83       	st	Z, r18
 306:	31 97       	sbiw	r30, 0x01	; 1
 308:	a3 e3       	ldi	r26, 0x33	; 51
 30a:	a0 83       	st	Z, r26
 30c:	31 97       	sbiw	r30, 0x01	; 1
 30e:	60 83       	st	Z, r22
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	70 83       	st	Z, r23
 314:	31 97       	sbiw	r30, 0x01	; 1
 316:	10 82       	st	Z, r1
 318:	31 97       	sbiw	r30, 0x01	; 1
 31a:	10 82       	st	Z, r1
 31c:	31 97       	sbiw	r30, 0x01	; 1
 31e:	60 e8       	ldi	r22, 0x80	; 128
 320:	60 83       	st	Z, r22
 322:	31 97       	sbiw	r30, 0x01	; 1
 324:	10 82       	st	Z, r1
 326:	31 97       	sbiw	r30, 0x01	; 1
 328:	10 82       	st	Z, r1
 32a:	31 97       	sbiw	r30, 0x01	; 1
 32c:	10 82       	st	Z, r1
 32e:	31 97       	sbiw	r30, 0x01	; 1
 330:	62 e0       	ldi	r22, 0x02	; 2
 332:	60 83       	st	Z, r22
 334:	31 97       	sbiw	r30, 0x01	; 1
 336:	63 e0       	ldi	r22, 0x03	; 3
 338:	60 83       	st	Z, r22
 33a:	31 97       	sbiw	r30, 0x01	; 1
 33c:	64 e0       	ldi	r22, 0x04	; 4
 33e:	60 83       	st	Z, r22
 340:	31 97       	sbiw	r30, 0x01	; 1
 342:	65 e0       	ldi	r22, 0x05	; 5
 344:	60 83       	st	Z, r22
 346:	31 97       	sbiw	r30, 0x01	; 1
 348:	66 e0       	ldi	r22, 0x06	; 6
 34a:	60 83       	st	Z, r22
 34c:	31 97       	sbiw	r30, 0x01	; 1
 34e:	67 e0       	ldi	r22, 0x07	; 7
 350:	60 83       	st	Z, r22
 352:	31 97       	sbiw	r30, 0x01	; 1
 354:	68 e0       	ldi	r22, 0x08	; 8
 356:	60 83       	st	Z, r22
 358:	31 97       	sbiw	r30, 0x01	; 1
 35a:	69 e0       	ldi	r22, 0x09	; 9
 35c:	60 83       	st	Z, r22
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	60 e1       	ldi	r22, 0x10	; 16
 362:	60 83       	st	Z, r22
 364:	31 97       	sbiw	r30, 0x01	; 1
 366:	30 83       	st	Z, r19
 368:	31 97       	sbiw	r30, 0x01	; 1
 36a:	32 e1       	ldi	r19, 0x12	; 18
 36c:	30 83       	st	Z, r19
 36e:	31 97       	sbiw	r30, 0x01	; 1
 370:	33 e1       	ldi	r19, 0x13	; 19
 372:	30 83       	st	Z, r19
 374:	31 97       	sbiw	r30, 0x01	; 1
 376:	34 e1       	ldi	r19, 0x14	; 20
 378:	30 83       	st	Z, r19
 37a:	31 97       	sbiw	r30, 0x01	; 1
 37c:	35 e1       	ldi	r19, 0x15	; 21
 37e:	30 83       	st	Z, r19
 380:	31 97       	sbiw	r30, 0x01	; 1
 382:	36 e1       	ldi	r19, 0x16	; 22
 384:	30 83       	st	Z, r19
 386:	31 97       	sbiw	r30, 0x01	; 1
 388:	37 e1       	ldi	r19, 0x17	; 23
 38a:	30 83       	st	Z, r19
 38c:	31 97       	sbiw	r30, 0x01	; 1
 38e:	38 e1       	ldi	r19, 0x18	; 24
 390:	30 83       	st	Z, r19
 392:	31 97       	sbiw	r30, 0x01	; 1
 394:	39 e1       	ldi	r19, 0x19	; 25
 396:	30 83       	st	Z, r19
 398:	31 97       	sbiw	r30, 0x01	; 1
 39a:	30 e2       	ldi	r19, 0x20	; 32
 39c:	30 83       	st	Z, r19
 39e:	31 97       	sbiw	r30, 0x01	; 1
 3a0:	31 e2       	ldi	r19, 0x21	; 33
 3a2:	30 83       	st	Z, r19
 3a4:	31 97       	sbiw	r30, 0x01	; 1
 3a6:	20 83       	st	Z, r18
 3a8:	31 97       	sbiw	r30, 0x01	; 1
 3aa:	23 e2       	ldi	r18, 0x23	; 35
 3ac:	20 83       	st	Z, r18
 3ae:	31 97       	sbiw	r30, 0x01	; 1
 3b0:	40 83       	st	Z, r20
 3b2:	31 97       	sbiw	r30, 0x01	; 1
 3b4:	50 83       	st	Z, r21
 3b6:	31 97       	sbiw	r30, 0x01	; 1
 3b8:	26 e2       	ldi	r18, 0x26	; 38
 3ba:	20 83       	st	Z, r18
 3bc:	31 97       	sbiw	r30, 0x01	; 1
 3be:	27 e2       	ldi	r18, 0x27	; 39
 3c0:	20 83       	st	Z, r18
 3c2:	31 97       	sbiw	r30, 0x01	; 1
 3c4:	28 e2       	ldi	r18, 0x28	; 40
 3c6:	20 83       	st	Z, r18
 3c8:	31 97       	sbiw	r30, 0x01	; 1
 3ca:	29 e2       	ldi	r18, 0x29	; 41
 3cc:	20 83       	st	Z, r18
 3ce:	31 97       	sbiw	r30, 0x01	; 1
 3d0:	20 e3       	ldi	r18, 0x30	; 48
 3d2:	20 83       	st	Z, r18
 3d4:	31 97       	sbiw	r30, 0x01	; 1
 3d6:	21 e3       	ldi	r18, 0x31	; 49
 3d8:	20 83       	st	Z, r18
 3da:	89 97       	sbiw	r24, 0x29	; 41
 3dc:	08 95       	ret

000003de <xPortStartScheduler>:
 3de:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
 3e2:	89 ef       	ldi	r24, 0xF9	; 249
 3e4:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
 3e8:	8b e0       	ldi	r24, 0x0B	; 11
 3ea:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
 3ee:	e3 e7       	ldi	r30, 0x73	; 115
 3f0:	f0 e0       	ldi	r31, 0x00	; 0
 3f2:	80 81       	ld	r24, Z
 3f4:	82 60       	ori	r24, 0x02	; 2
 3f6:	80 83       	st	Z, r24
 3f8:	a0 91 23 08 	lds	r26, 0x0823	; 0x800823 <pxCurrentTCB>
 3fc:	b0 91 24 08 	lds	r27, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 400:	cd 91       	ld	r28, X+
 402:	cd bf       	out	0x3d, r28	; 61
 404:	dd 91       	ld	r29, X+
 406:	de bf       	out	0x3e, r29	; 62
 408:	ff 91       	pop	r31
 40a:	ef 91       	pop	r30
 40c:	df 91       	pop	r29
 40e:	cf 91       	pop	r28
 410:	bf 91       	pop	r27
 412:	af 91       	pop	r26
 414:	9f 91       	pop	r25
 416:	8f 91       	pop	r24
 418:	7f 91       	pop	r23
 41a:	6f 91       	pop	r22
 41c:	5f 91       	pop	r21
 41e:	4f 91       	pop	r20
 420:	3f 91       	pop	r19
 422:	2f 91       	pop	r18
 424:	1f 91       	pop	r17
 426:	0f 91       	pop	r16
 428:	ff 90       	pop	r15
 42a:	ef 90       	pop	r14
 42c:	df 90       	pop	r13
 42e:	cf 90       	pop	r12
 430:	bf 90       	pop	r11
 432:	af 90       	pop	r10
 434:	9f 90       	pop	r9
 436:	8f 90       	pop	r8
 438:	7f 90       	pop	r7
 43a:	6f 90       	pop	r6
 43c:	5f 90       	pop	r5
 43e:	4f 90       	pop	r4
 440:	3f 90       	pop	r3
 442:	2f 90       	pop	r2
 444:	1f 90       	pop	r1
 446:	0f 90       	pop	r0
 448:	0c be       	out	0x3c, r0	; 60
 44a:	0f 90       	pop	r0
 44c:	0b be       	out	0x3b, r0	; 59
 44e:	0f 90       	pop	r0
 450:	0f be       	out	0x3f, r0	; 63
 452:	0f 90       	pop	r0
 454:	08 95       	ret
 456:	81 e0       	ldi	r24, 0x01	; 1
 458:	08 95       	ret

0000045a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 45a:	0f 92       	push	r0
 45c:	0f b6       	in	r0, 0x3f	; 63
 45e:	f8 94       	cli
 460:	0f 92       	push	r0
 462:	0b b6       	in	r0, 0x3b	; 59
 464:	0f 92       	push	r0
 466:	0c b6       	in	r0, 0x3c	; 60
 468:	0f 92       	push	r0
 46a:	1f 92       	push	r1
 46c:	11 24       	eor	r1, r1
 46e:	2f 92       	push	r2
 470:	3f 92       	push	r3
 472:	4f 92       	push	r4
 474:	5f 92       	push	r5
 476:	6f 92       	push	r6
 478:	7f 92       	push	r7
 47a:	8f 92       	push	r8
 47c:	9f 92       	push	r9
 47e:	af 92       	push	r10
 480:	bf 92       	push	r11
 482:	cf 92       	push	r12
 484:	df 92       	push	r13
 486:	ef 92       	push	r14
 488:	ff 92       	push	r15
 48a:	0f 93       	push	r16
 48c:	1f 93       	push	r17
 48e:	2f 93       	push	r18
 490:	3f 93       	push	r19
 492:	4f 93       	push	r20
 494:	5f 93       	push	r21
 496:	6f 93       	push	r22
 498:	7f 93       	push	r23
 49a:	8f 93       	push	r24
 49c:	9f 93       	push	r25
 49e:	af 93       	push	r26
 4a0:	bf 93       	push	r27
 4a2:	cf 93       	push	r28
 4a4:	df 93       	push	r29
 4a6:	ef 93       	push	r30
 4a8:	ff 93       	push	r31
 4aa:	a0 91 23 08 	lds	r26, 0x0823	; 0x800823 <pxCurrentTCB>
 4ae:	b0 91 24 08 	lds	r27, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 4b2:	0d b6       	in	r0, 0x3d	; 61
 4b4:	0d 92       	st	X+, r0
 4b6:	0e b6       	in	r0, 0x3e	; 62
 4b8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 4ba:	94 d3       	rcall	.+1832   	; 0xbe4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4bc:	a0 91 23 08 	lds	r26, 0x0823	; 0x800823 <pxCurrentTCB>
 4c0:	b0 91 24 08 	lds	r27, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 4c4:	cd 91       	ld	r28, X+
 4c6:	cd bf       	out	0x3d, r28	; 61
 4c8:	dd 91       	ld	r29, X+
 4ca:	de bf       	out	0x3e, r29	; 62
 4cc:	ff 91       	pop	r31
 4ce:	ef 91       	pop	r30
 4d0:	df 91       	pop	r29
 4d2:	cf 91       	pop	r28
 4d4:	bf 91       	pop	r27
 4d6:	af 91       	pop	r26
 4d8:	9f 91       	pop	r25
 4da:	8f 91       	pop	r24
 4dc:	7f 91       	pop	r23
 4de:	6f 91       	pop	r22
 4e0:	5f 91       	pop	r21
 4e2:	4f 91       	pop	r20
 4e4:	3f 91       	pop	r19
 4e6:	2f 91       	pop	r18
 4e8:	1f 91       	pop	r17
 4ea:	0f 91       	pop	r16
 4ec:	ff 90       	pop	r15
 4ee:	ef 90       	pop	r14
 4f0:	df 90       	pop	r13
 4f2:	cf 90       	pop	r12
 4f4:	bf 90       	pop	r11
 4f6:	af 90       	pop	r10
 4f8:	9f 90       	pop	r9
 4fa:	8f 90       	pop	r8
 4fc:	7f 90       	pop	r7
 4fe:	6f 90       	pop	r6
 500:	5f 90       	pop	r5
 502:	4f 90       	pop	r4
 504:	3f 90       	pop	r3
 506:	2f 90       	pop	r2
 508:	1f 90       	pop	r1
 50a:	0f 90       	pop	r0
 50c:	0c be       	out	0x3c, r0	; 60
 50e:	0f 90       	pop	r0
 510:	0b be       	out	0x3b, r0	; 59
 512:	0f 90       	pop	r0
 514:	0f be       	out	0x3f, r0	; 63
 516:	0f 90       	pop	r0

	asm volatile ( "ret" );
 518:	08 95       	ret

0000051a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 51a:	0f 92       	push	r0
 51c:	0f b6       	in	r0, 0x3f	; 63
 51e:	f8 94       	cli
 520:	0f 92       	push	r0
 522:	0b b6       	in	r0, 0x3b	; 59
 524:	0f 92       	push	r0
 526:	0c b6       	in	r0, 0x3c	; 60
 528:	0f 92       	push	r0
 52a:	1f 92       	push	r1
 52c:	11 24       	eor	r1, r1
 52e:	2f 92       	push	r2
 530:	3f 92       	push	r3
 532:	4f 92       	push	r4
 534:	5f 92       	push	r5
 536:	6f 92       	push	r6
 538:	7f 92       	push	r7
 53a:	8f 92       	push	r8
 53c:	9f 92       	push	r9
 53e:	af 92       	push	r10
 540:	bf 92       	push	r11
 542:	cf 92       	push	r12
 544:	df 92       	push	r13
 546:	ef 92       	push	r14
 548:	ff 92       	push	r15
 54a:	0f 93       	push	r16
 54c:	1f 93       	push	r17
 54e:	2f 93       	push	r18
 550:	3f 93       	push	r19
 552:	4f 93       	push	r20
 554:	5f 93       	push	r21
 556:	6f 93       	push	r22
 558:	7f 93       	push	r23
 55a:	8f 93       	push	r24
 55c:	9f 93       	push	r25
 55e:	af 93       	push	r26
 560:	bf 93       	push	r27
 562:	cf 93       	push	r28
 564:	df 93       	push	r29
 566:	ef 93       	push	r30
 568:	ff 93       	push	r31
 56a:	a0 91 23 08 	lds	r26, 0x0823	; 0x800823 <pxCurrentTCB>
 56e:	b0 91 24 08 	lds	r27, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 572:	0d b6       	in	r0, 0x3d	; 61
 574:	0d 92       	st	X+, r0
 576:	0e b6       	in	r0, 0x3e	; 62
 578:	0d 92       	st	X+, r0
	vTaskIncrementTick();
 57a:	ad d1       	rcall	.+858    	; 0x8d6 <vTaskIncrementTick>
	vTaskSwitchContext();
 57c:	33 d3       	rcall	.+1638   	; 0xbe4 <vTaskSwitchContext>
 57e:	a0 91 23 08 	lds	r26, 0x0823	; 0x800823 <pxCurrentTCB>
	portRESTORE_CONTEXT();
 582:	b0 91 24 08 	lds	r27, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 586:	cd 91       	ld	r28, X+
 588:	cd bf       	out	0x3d, r28	; 61
 58a:	dd 91       	ld	r29, X+
 58c:	de bf       	out	0x3e, r29	; 62
 58e:	ff 91       	pop	r31
 590:	ef 91       	pop	r30
 592:	df 91       	pop	r29
 594:	cf 91       	pop	r28
 596:	bf 91       	pop	r27
 598:	af 91       	pop	r26
 59a:	9f 91       	pop	r25
 59c:	8f 91       	pop	r24
 59e:	7f 91       	pop	r23
 5a0:	6f 91       	pop	r22
 5a2:	5f 91       	pop	r21
 5a4:	4f 91       	pop	r20
 5a6:	3f 91       	pop	r19
 5a8:	2f 91       	pop	r18
 5aa:	1f 91       	pop	r17
 5ac:	0f 91       	pop	r16
 5ae:	ff 90       	pop	r15
 5b0:	ef 90       	pop	r14
 5b2:	df 90       	pop	r13
 5b4:	cf 90       	pop	r12
 5b6:	bf 90       	pop	r11
 5b8:	af 90       	pop	r10
 5ba:	9f 90       	pop	r9
 5bc:	8f 90       	pop	r8
 5be:	7f 90       	pop	r7
 5c0:	6f 90       	pop	r6
 5c2:	5f 90       	pop	r5
 5c4:	4f 90       	pop	r4
 5c6:	3f 90       	pop	r3
 5c8:	2f 90       	pop	r2
 5ca:	1f 90       	pop	r1
 5cc:	0f 90       	pop	r0
 5ce:	0c be       	out	0x3c, r0	; 60
 5d0:	0f 90       	pop	r0
 5d2:	0b be       	out	0x3b, r0	; 59
 5d4:	0f 90       	pop	r0
 5d6:	0f be       	out	0x3f, r0	; 63
 5d8:	0f 90       	pop	r0
 5da:	08 95       	ret

000005dc <__vector_47>:
	asm volatile ( "ret" );
 5dc:	9e df       	rcall	.-196    	; 0x51a <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER5_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER5_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
 5de:	18 95       	reti

000005e0 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 5e0:	cf 93       	push	r28
 5e2:	df 93       	push	r29
 5e4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 5e6:	67 d1       	rcall	.+718    	; 0x8b6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 5e8:	20 91 12 02 	lds	r18, 0x0212	; 0x800212 <__data_end>
 5ec:	30 91 13 02 	lds	r19, 0x0213	; 0x800213 <__data_end+0x1>
 5f0:	c9 01       	movw	r24, r18
 5f2:	8c 0f       	add	r24, r28
 5f4:	9d 1f       	adc	r25, r29
 5f6:	8c 3d       	cpi	r24, 0xDC	; 220
 5f8:	45 e0       	ldi	r20, 0x05	; 5
 5fa:	94 07       	cpc	r25, r20
 5fc:	58 f4       	brcc	.+22     	; 0x614 <pvPortMalloc+0x34>
 5fe:	28 17       	cp	r18, r24
 600:	39 07       	cpc	r19, r25
 602:	58 f4       	brcc	.+22     	; 0x61a <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 604:	e9 01       	movw	r28, r18
 606:	cc 5e       	subi	r28, 0xEC	; 236
 608:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
 60a:	90 93 13 02 	sts	0x0213, r25	; 0x800213 <__data_end+0x1>
 60e:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <__data_end>
 612:	05 c0       	rjmp	.+10     	; 0x61e <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
 614:	c0 e0       	ldi	r28, 0x00	; 0
 616:	d0 e0       	ldi	r29, 0x00	; 0
 618:	02 c0       	rjmp	.+4      	; 0x61e <pvPortMalloc+0x3e>
 61a:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 61c:	d0 e0       	ldi	r29, 0x00	; 0
 61e:	1c d2       	rcall	.+1080   	; 0xa58 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
 620:	ce 01       	movw	r24, r28
 622:	df 91       	pop	r29
 624:	cf 91       	pop	r28
 626:	08 95       	ret

00000628 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 628:	08 95       	ret

0000062a <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 62a:	ca e1       	ldi	r28, 0x1A	; 26
 62c:	d8 e0       	ldi	r29, 0x08	; 8
 62e:	88 81       	ld	r24, Y
 630:	82 30       	cpi	r24, 0x02	; 2
 632:	e8 f3       	brcs	.-6      	; 0x62e <prvIdleTask+0x4>
 634:	12 df       	rcall	.-476    	; 0x45a <vPortYield>
 636:	fb cf       	rjmp	.-10     	; 0x62e <prvIdleTask+0x4>

00000638 <prvAddCurrentTaskToDelayedList>:
 638:	cf 93       	push	r28
 63a:	df 93       	push	r29
 63c:	ec 01       	movw	r28, r24
 63e:	e0 91 23 08 	lds	r30, 0x0823	; 0x800823 <pxCurrentTCB>
 642:	f0 91 24 08 	lds	r31, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 646:	93 83       	std	Z+3, r25	; 0x03
 648:	82 83       	std	Z+2, r24	; 0x02
 64a:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTickCount>
 64e:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 652:	c8 17       	cp	r28, r24
 654:	d9 07       	cpc	r29, r25
 656:	60 f4       	brcc	.+24     	; 0x670 <prvAddCurrentTaskToDelayedList+0x38>
 658:	60 91 23 08 	lds	r22, 0x0823	; 0x800823 <pxCurrentTCB>
 65c:	70 91 24 08 	lds	r23, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 660:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <pxOverflowDelayedTaskList>
 664:	90 91 05 08 	lds	r25, 0x0805	; 0x800805 <pxOverflowDelayedTaskList+0x1>
 668:	6e 5f       	subi	r22, 0xFE	; 254
 66a:	7f 4f       	sbci	r23, 0xFF	; 255
 66c:	e5 dd       	rcall	.-1078   	; 0x238 <vListInsert>
 66e:	16 c0       	rjmp	.+44     	; 0x69c <prvAddCurrentTaskToDelayedList+0x64>
 670:	60 91 23 08 	lds	r22, 0x0823	; 0x800823 <pxCurrentTCB>
 674:	70 91 24 08 	lds	r23, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 678:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <pxDelayedTaskList>
 67c:	90 91 07 08 	lds	r25, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 680:	6e 5f       	subi	r22, 0xFE	; 254
 682:	7f 4f       	sbci	r23, 0xFF	; 255
 684:	d9 dd       	rcall	.-1102   	; 0x238 <vListInsert>
 686:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
 68a:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
 68e:	c8 17       	cp	r28, r24
 690:	d9 07       	cpc	r29, r25
 692:	20 f4       	brcc	.+8      	; 0x69c <prvAddCurrentTaskToDelayedList+0x64>
 694:	d0 93 01 02 	sts	0x0201, r29	; 0x800201 <__data_start+0x1>
 698:	c0 93 00 02 	sts	0x0200, r28	; 0x800200 <__data_start>
 69c:	df 91       	pop	r29
 69e:	cf 91       	pop	r28
 6a0:	08 95       	ret

000006a2 <xTaskGenericCreate>:
 6a2:	4f 92       	push	r4
 6a4:	5f 92       	push	r5
 6a6:	6f 92       	push	r6
 6a8:	7f 92       	push	r7
 6aa:	8f 92       	push	r8
 6ac:	9f 92       	push	r9
 6ae:	af 92       	push	r10
 6b0:	bf 92       	push	r11
 6b2:	cf 92       	push	r12
 6b4:	df 92       	push	r13
 6b6:	ef 92       	push	r14
 6b8:	ff 92       	push	r15
 6ba:	0f 93       	push	r16
 6bc:	cf 93       	push	r28
 6be:	df 93       	push	r29
 6c0:	5c 01       	movw	r10, r24
 6c2:	4b 01       	movw	r8, r22
 6c4:	3a 01       	movw	r6, r20
 6c6:	29 01       	movw	r4, r18
 6c8:	81 e2       	ldi	r24, 0x21	; 33
 6ca:	90 e0       	ldi	r25, 0x00	; 0
 6cc:	89 df       	rcall	.-238    	; 0x5e0 <pvPortMalloc>
 6ce:	ec 01       	movw	r28, r24
 6d0:	89 2b       	or	r24, r25
 6d2:	09 f4       	brne	.+2      	; 0x6d6 <xTaskGenericCreate+0x34>
 6d4:	9c c0       	rjmp	.+312    	; 0x80e <xTaskGenericCreate+0x16c>
 6d6:	c1 14       	cp	r12, r1
 6d8:	d1 04       	cpc	r13, r1
 6da:	09 f0       	breq	.+2      	; 0x6de <xTaskGenericCreate+0x3c>
 6dc:	94 c0       	rjmp	.+296    	; 0x806 <xTaskGenericCreate+0x164>
 6de:	c3 01       	movw	r24, r6
 6e0:	7f df       	rcall	.-258    	; 0x5e0 <pvPortMalloc>
 6e2:	98 8f       	std	Y+24, r25	; 0x18
 6e4:	8f 8b       	std	Y+23, r24	; 0x17
 6e6:	00 97       	sbiw	r24, 0x00	; 0
 6e8:	19 f4       	brne	.+6      	; 0x6f0 <xTaskGenericCreate+0x4e>
 6ea:	ce 01       	movw	r24, r28
 6ec:	9d df       	rcall	.-198    	; 0x628 <vPortFree>
 6ee:	8f c0       	rjmp	.+286    	; 0x80e <xTaskGenericCreate+0x16c>
 6f0:	a3 01       	movw	r20, r6
 6f2:	65 ea       	ldi	r22, 0xA5	; 165
 6f4:	70 e0       	ldi	r23, 0x00	; 0
 6f6:	e2 d2       	rcall	.+1476   	; 0xcbc <memset>
 6f8:	93 01       	movw	r18, r6
 6fa:	21 50       	subi	r18, 0x01	; 1
 6fc:	31 09       	sbc	r19, r1
 6fe:	8f 89       	ldd	r24, Y+23	; 0x17
 700:	98 8d       	ldd	r25, Y+24	; 0x18
 702:	3c 01       	movw	r6, r24
 704:	62 0e       	add	r6, r18
 706:	73 1e       	adc	r7, r19
 708:	48 e0       	ldi	r20, 0x08	; 8
 70a:	50 e0       	ldi	r21, 0x00	; 0
 70c:	b4 01       	movw	r22, r8
 70e:	ce 01       	movw	r24, r28
 710:	49 96       	adiw	r24, 0x19	; 25
 712:	db d2       	rcall	.+1462   	; 0xcca <strncpy>
 714:	18 a2       	std	Y+32, r1	; 0x20
 716:	1e 8a       	std	Y+22, r1	; 0x16
 718:	6e 01       	movw	r12, r28
 71a:	82 e0       	ldi	r24, 0x02	; 2
 71c:	c8 0e       	add	r12, r24
 71e:	d1 1c       	adc	r13, r1
 720:	c6 01       	movw	r24, r12
 722:	5f dd       	rcall	.-1346   	; 0x1e2 <vListInitialiseItem>
 724:	ce 01       	movw	r24, r28
 726:	0c 96       	adiw	r24, 0x0c	; 12
 728:	5c dd       	rcall	.-1352   	; 0x1e2 <vListInitialiseItem>
 72a:	d9 87       	std	Y+9, r29	; 0x09
 72c:	c8 87       	std	Y+8, r28	; 0x08
 72e:	81 e0       	ldi	r24, 0x01	; 1
 730:	90 e0       	ldi	r25, 0x00	; 0
 732:	9d 87       	std	Y+13, r25	; 0x0d
 734:	8c 87       	std	Y+12, r24	; 0x0c
 736:	db 8b       	std	Y+19, r29	; 0x13
 738:	ca 8b       	std	Y+18, r28	; 0x12
 73a:	a2 01       	movw	r20, r4
 73c:	b5 01       	movw	r22, r10
 73e:	c3 01       	movw	r24, r6
 740:	dc dd       	rcall	.-1096   	; 0x2fa <pxPortInitialiseStack>
 742:	99 83       	std	Y+1, r25	; 0x01
 744:	88 83       	st	Y, r24
 746:	e1 14       	cp	r14, r1
 748:	f1 04       	cpc	r15, r1
 74a:	19 f0       	breq	.+6      	; 0x752 <xTaskGenericCreate+0xb0>
 74c:	f7 01       	movw	r30, r14
 74e:	d1 83       	std	Z+1, r29	; 0x01
 750:	c0 83       	st	Z, r28
 752:	0f b6       	in	r0, 0x3f	; 63
 754:	f8 94       	cli
 756:	0f 92       	push	r0
 758:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <uxCurrentNumberOfTasks>
 75c:	8f 5f       	subi	r24, 0xFF	; 255
 75e:	80 93 fa 07 	sts	0x07FA, r24	; 0x8007fa <uxCurrentNumberOfTasks>
 762:	80 91 23 08 	lds	r24, 0x0823	; 0x800823 <pxCurrentTCB>
 766:	90 91 24 08 	lds	r25, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 76a:	89 2b       	or	r24, r25
 76c:	49 f4       	brne	.+18     	; 0x780 <xTaskGenericCreate+0xde>
 76e:	d0 93 24 08 	sts	0x0824, r29	; 0x800824 <pxCurrentTCB+0x1>
 772:	c0 93 23 08 	sts	0x0823, r28	; 0x800823 <pxCurrentTCB>
 776:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <uxCurrentNumberOfTasks>
 77a:	81 30       	cpi	r24, 0x01	; 1
 77c:	81 f4       	brne	.+32     	; 0x79e <xTaskGenericCreate+0xfc>
 77e:	49 c0       	rjmp	.+146    	; 0x812 <xTaskGenericCreate+0x170>
 780:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <xSchedulerRunning>
 784:	81 11       	cpse	r24, r1
 786:	0b c0       	rjmp	.+22     	; 0x79e <xTaskGenericCreate+0xfc>
 788:	e0 91 23 08 	lds	r30, 0x0823	; 0x800823 <pxCurrentTCB>
 78c:	f0 91 24 08 	lds	r31, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 790:	86 89       	ldd	r24, Z+22	; 0x16
 792:	08 17       	cp	r16, r24
 794:	20 f0       	brcs	.+8      	; 0x79e <xTaskGenericCreate+0xfc>
 796:	d0 93 24 08 	sts	0x0824, r29	; 0x800824 <pxCurrentTCB+0x1>
 79a:	c0 93 23 08 	sts	0x0823, r28	; 0x800823 <pxCurrentTCB>
 79e:	8e 89       	ldd	r24, Y+22	; 0x16
 7a0:	90 91 f7 07 	lds	r25, 0x07F7	; 0x8007f7 <uxTopUsedPriority>
 7a4:	98 17       	cp	r25, r24
 7a6:	10 f4       	brcc	.+4      	; 0x7ac <xTaskGenericCreate+0x10a>
 7a8:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <uxTopUsedPriority>
 7ac:	90 91 f0 07 	lds	r25, 0x07F0	; 0x8007f0 <uxTCBNumber>
 7b0:	9f 5f       	subi	r25, 0xFF	; 255
 7b2:	90 93 f0 07 	sts	0x07F0, r25	; 0x8007f0 <uxTCBNumber>
 7b6:	90 91 f6 07 	lds	r25, 0x07F6	; 0x8007f6 <uxTopReadyPriority>
 7ba:	98 17       	cp	r25, r24
 7bc:	10 f4       	brcc	.+4      	; 0x7c2 <xTaskGenericCreate+0x120>
 7be:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <uxTopReadyPriority>
 7c2:	90 e0       	ldi	r25, 0x00	; 0
 7c4:	9c 01       	movw	r18, r24
 7c6:	22 0f       	add	r18, r18
 7c8:	33 1f       	adc	r19, r19
 7ca:	22 0f       	add	r18, r18
 7cc:	33 1f       	adc	r19, r19
 7ce:	22 0f       	add	r18, r18
 7d0:	33 1f       	adc	r19, r19
 7d2:	82 0f       	add	r24, r18
 7d4:	93 1f       	adc	r25, r19
 7d6:	b6 01       	movw	r22, r12
 7d8:	86 5e       	subi	r24, 0xE6	; 230
 7da:	97 4f       	sbci	r25, 0xF7	; 247
 7dc:	06 dd       	rcall	.-1524   	; 0x1ea <vListInsertEnd>
 7de:	0f 90       	pop	r0
 7e0:	0f be       	out	0x3f, r0	; 63
 7e2:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <xSchedulerRunning>
 7e6:	88 23       	and	r24, r24
 7e8:	51 f0       	breq	.+20     	; 0x7fe <xTaskGenericCreate+0x15c>
 7ea:	e0 91 23 08 	lds	r30, 0x0823	; 0x800823 <pxCurrentTCB>
 7ee:	f0 91 24 08 	lds	r31, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 7f2:	86 89       	ldd	r24, Z+22	; 0x16
 7f4:	80 17       	cp	r24, r16
 7f6:	28 f4       	brcc	.+10     	; 0x802 <xTaskGenericCreate+0x160>
 7f8:	30 de       	rcall	.-928    	; 0x45a <vPortYield>
 7fa:	81 e0       	ldi	r24, 0x01	; 1
 7fc:	23 c0       	rjmp	.+70     	; 0x844 <xTaskGenericCreate+0x1a2>
 7fe:	81 e0       	ldi	r24, 0x01	; 1
 800:	21 c0       	rjmp	.+66     	; 0x844 <xTaskGenericCreate+0x1a2>
 802:	81 e0       	ldi	r24, 0x01	; 1
 804:	1f c0       	rjmp	.+62     	; 0x844 <xTaskGenericCreate+0x1a2>
 806:	d8 8e       	std	Y+24, r13	; 0x18
 808:	cf 8a       	std	Y+23, r12	; 0x17
 80a:	c6 01       	movw	r24, r12
 80c:	71 cf       	rjmp	.-286    	; 0x6f0 <xTaskGenericCreate+0x4e>
 80e:	8f ef       	ldi	r24, 0xFF	; 255
 810:	19 c0       	rjmp	.+50     	; 0x844 <xTaskGenericCreate+0x1a2>
 812:	8a e1       	ldi	r24, 0x1A	; 26
 814:	98 e0       	ldi	r25, 0x08	; 8
 816:	d7 dc       	rcall	.-1618   	; 0x1c6 <vListInitialise>
 818:	81 e1       	ldi	r24, 0x11	; 17
 81a:	98 e0       	ldi	r25, 0x08	; 8
 81c:	d4 dc       	rcall	.-1624   	; 0x1c6 <vListInitialise>
 81e:	88 e0       	ldi	r24, 0x08	; 8
 820:	98 e0       	ldi	r25, 0x08	; 8
 822:	d1 dc       	rcall	.-1630   	; 0x1c6 <vListInitialise>
 824:	8b ef       	ldi	r24, 0xFB	; 251
 826:	97 e0       	ldi	r25, 0x07	; 7
 828:	ce dc       	rcall	.-1636   	; 0x1c6 <vListInitialise>
 82a:	81 e1       	ldi	r24, 0x11	; 17
 82c:	98 e0       	ldi	r25, 0x08	; 8
 82e:	90 93 07 08 	sts	0x0807, r25	; 0x800807 <pxDelayedTaskList+0x1>
 832:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <pxDelayedTaskList>
 836:	88 e0       	ldi	r24, 0x08	; 8
 838:	98 e0       	ldi	r25, 0x08	; 8
 83a:	90 93 05 08 	sts	0x0805, r25	; 0x800805 <pxOverflowDelayedTaskList+0x1>
 83e:	80 93 04 08 	sts	0x0804, r24	; 0x800804 <pxOverflowDelayedTaskList>
 842:	ad cf       	rjmp	.-166    	; 0x79e <xTaskGenericCreate+0xfc>
 844:	df 91       	pop	r29
 846:	cf 91       	pop	r28
 848:	0f 91       	pop	r16
 84a:	ff 90       	pop	r15
 84c:	ef 90       	pop	r14
 84e:	df 90       	pop	r13
 850:	cf 90       	pop	r12
 852:	bf 90       	pop	r11
 854:	af 90       	pop	r10
 856:	9f 90       	pop	r9
 858:	8f 90       	pop	r8
 85a:	7f 90       	pop	r7
 85c:	6f 90       	pop	r6
 85e:	5f 90       	pop	r5
 860:	4f 90       	pop	r4
 862:	08 95       	ret

00000864 <vTaskStartScheduler>:
 864:	af 92       	push	r10
 866:	bf 92       	push	r11
 868:	cf 92       	push	r12
 86a:	df 92       	push	r13
 86c:	ef 92       	push	r14
 86e:	ff 92       	push	r15
 870:	0f 93       	push	r16
 872:	a1 2c       	mov	r10, r1
 874:	b1 2c       	mov	r11, r1
 876:	c1 2c       	mov	r12, r1
 878:	d1 2c       	mov	r13, r1
 87a:	e1 2c       	mov	r14, r1
 87c:	f1 2c       	mov	r15, r1
 87e:	00 e0       	ldi	r16, 0x00	; 0
 880:	20 e0       	ldi	r18, 0x00	; 0
 882:	30 e0       	ldi	r19, 0x00	; 0
 884:	45 e5       	ldi	r20, 0x55	; 85
 886:	50 e0       	ldi	r21, 0x00	; 0
 888:	6c e0       	ldi	r22, 0x0C	; 12
 88a:	72 e0       	ldi	r23, 0x02	; 2
 88c:	85 e1       	ldi	r24, 0x15	; 21
 88e:	93 e0       	ldi	r25, 0x03	; 3
 890:	08 df       	rcall	.-496    	; 0x6a2 <xTaskGenericCreate>
 892:	81 30       	cpi	r24, 0x01	; 1
 894:	41 f4       	brne	.+16     	; 0x8a6 <vTaskStartScheduler+0x42>
 896:	f8 94       	cli
 898:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <xSchedulerRunning>
 89c:	10 92 f9 07 	sts	0x07F9, r1	; 0x8007f9 <xTickCount+0x1>
 8a0:	10 92 f8 07 	sts	0x07F8, r1	; 0x8007f8 <xTickCount>
 8a4:	9c dd       	rcall	.-1224   	; 0x3de <xPortStartScheduler>
 8a6:	0f 91       	pop	r16
 8a8:	ff 90       	pop	r15
 8aa:	ef 90       	pop	r14
 8ac:	df 90       	pop	r13
 8ae:	cf 90       	pop	r12
 8b0:	bf 90       	pop	r11
 8b2:	af 90       	pop	r10
 8b4:	08 95       	ret

000008b6 <vTaskSuspendAll>:
 8b6:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 8ba:	8f 5f       	subi	r24, 0xFF	; 255
 8bc:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <uxSchedulerSuspended>
 8c0:	08 95       	ret

000008c2 <xTaskGetTickCount>:
 8c2:	0f b6       	in	r0, 0x3f	; 63
 8c4:	f8 94       	cli
 8c6:	0f 92       	push	r0
 8c8:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTickCount>
 8cc:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 8d0:	0f 90       	pop	r0
 8d2:	0f be       	out	0x3f, r0	; 63
 8d4:	08 95       	ret

000008d6 <vTaskIncrementTick>:
 8d6:	0f 93       	push	r16
 8d8:	1f 93       	push	r17
 8da:	cf 93       	push	r28
 8dc:	df 93       	push	r29
 8de:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 8e2:	81 11       	cpse	r24, r1
 8e4:	af c0       	rjmp	.+350    	; 0xa44 <vTaskIncrementTick+0x16e>
 8e6:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTickCount>
 8ea:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 8ee:	01 96       	adiw	r24, 0x01	; 1
 8f0:	90 93 f9 07 	sts	0x07F9, r25	; 0x8007f9 <xTickCount+0x1>
 8f4:	80 93 f8 07 	sts	0x07F8, r24	; 0x8007f8 <xTickCount>
 8f8:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTickCount>
 8fc:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 900:	89 2b       	or	r24, r25
 902:	99 f5       	brne	.+102    	; 0x96a <vTaskIncrementTick+0x94>
 904:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <pxDelayedTaskList>
 908:	90 91 07 08 	lds	r25, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 90c:	20 91 04 08 	lds	r18, 0x0804	; 0x800804 <pxOverflowDelayedTaskList>
 910:	30 91 05 08 	lds	r19, 0x0805	; 0x800805 <pxOverflowDelayedTaskList+0x1>
 914:	30 93 07 08 	sts	0x0807, r19	; 0x800807 <pxDelayedTaskList+0x1>
 918:	20 93 06 08 	sts	0x0806, r18	; 0x800806 <pxDelayedTaskList>
 91c:	90 93 05 08 	sts	0x0805, r25	; 0x800805 <pxOverflowDelayedTaskList+0x1>
 920:	80 93 04 08 	sts	0x0804, r24	; 0x800804 <pxOverflowDelayedTaskList>
 924:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <xNumOfOverflows>
 928:	8f 5f       	subi	r24, 0xFF	; 255
 92a:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <xNumOfOverflows>
 92e:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxDelayedTaskList>
 932:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 936:	80 81       	ld	r24, Z
 938:	81 11       	cpse	r24, r1
 93a:	07 c0       	rjmp	.+14     	; 0x94a <vTaskIncrementTick+0x74>
 93c:	8f ef       	ldi	r24, 0xFF	; 255
 93e:	9f ef       	ldi	r25, 0xFF	; 255
 940:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
 944:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
 948:	10 c0       	rjmp	.+32     	; 0x96a <vTaskIncrementTick+0x94>
 94a:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxDelayedTaskList>
 94e:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 952:	05 80       	ldd	r0, Z+5	; 0x05
 954:	f6 81       	ldd	r31, Z+6	; 0x06
 956:	e0 2d       	mov	r30, r0
 958:	06 80       	ldd	r0, Z+6	; 0x06
 95a:	f7 81       	ldd	r31, Z+7	; 0x07
 95c:	e0 2d       	mov	r30, r0
 95e:	82 81       	ldd	r24, Z+2	; 0x02
 960:	93 81       	ldd	r25, Z+3	; 0x03
 962:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
 966:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
 96a:	20 91 f8 07 	lds	r18, 0x07F8	; 0x8007f8 <xTickCount>
 96e:	30 91 f9 07 	lds	r19, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 972:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
 976:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__data_start+0x1>
 97a:	28 17       	cp	r18, r24
 97c:	39 07       	cpc	r19, r25
 97e:	08 f4       	brcc	.+2      	; 0x982 <vTaskIncrementTick+0xac>
 980:	66 c0       	rjmp	.+204    	; 0xa4e <vTaskIncrementTick+0x178>
 982:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxDelayedTaskList>
 986:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 98a:	80 81       	ld	r24, Z
 98c:	88 23       	and	r24, r24
 98e:	99 f0       	breq	.+38     	; 0x9b6 <vTaskIncrementTick+0xe0>
 990:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxDelayedTaskList>
 994:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 998:	05 80       	ldd	r0, Z+5	; 0x05
 99a:	f6 81       	ldd	r31, Z+6	; 0x06
 99c:	e0 2d       	mov	r30, r0
 99e:	c6 81       	ldd	r28, Z+6	; 0x06
 9a0:	d7 81       	ldd	r29, Z+7	; 0x07
 9a2:	8a 81       	ldd	r24, Y+2	; 0x02
 9a4:	9b 81       	ldd	r25, Y+3	; 0x03
 9a6:	20 91 f8 07 	lds	r18, 0x07F8	; 0x8007f8 <xTickCount>
 9aa:	30 91 f9 07 	lds	r19, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 9ae:	28 17       	cp	r18, r24
 9b0:	39 07       	cpc	r19, r25
 9b2:	f8 f4       	brcc	.+62     	; 0x9f2 <vTaskIncrementTick+0x11c>
 9b4:	19 c0       	rjmp	.+50     	; 0x9e8 <vTaskIncrementTick+0x112>
 9b6:	8f ef       	ldi	r24, 0xFF	; 255
 9b8:	9f ef       	ldi	r25, 0xFF	; 255
 9ba:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
 9be:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
 9c2:	45 c0       	rjmp	.+138    	; 0xa4e <vTaskIncrementTick+0x178>
 9c4:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxDelayedTaskList>
 9c8:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 9cc:	05 80       	ldd	r0, Z+5	; 0x05
 9ce:	f6 81       	ldd	r31, Z+6	; 0x06
 9d0:	e0 2d       	mov	r30, r0
 9d2:	c6 81       	ldd	r28, Z+6	; 0x06
 9d4:	d7 81       	ldd	r29, Z+7	; 0x07
 9d6:	8a 81       	ldd	r24, Y+2	; 0x02
 9d8:	9b 81       	ldd	r25, Y+3	; 0x03
 9da:	20 91 f8 07 	lds	r18, 0x07F8	; 0x8007f8 <xTickCount>
 9de:	30 91 f9 07 	lds	r19, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 9e2:	28 17       	cp	r18, r24
 9e4:	39 07       	cpc	r19, r25
 9e6:	28 f4       	brcc	.+10     	; 0x9f2 <vTaskIncrementTick+0x11c>
 9e8:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__data_start+0x1>
 9ec:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__data_start>
 9f0:	2e c0       	rjmp	.+92     	; 0xa4e <vTaskIncrementTick+0x178>
 9f2:	8e 01       	movw	r16, r28
 9f4:	0e 5f       	subi	r16, 0xFE	; 254
 9f6:	1f 4f       	sbci	r17, 0xFF	; 255
 9f8:	c8 01       	movw	r24, r16
 9fa:	59 dc       	rcall	.-1870   	; 0x2ae <vListRemove>
 9fc:	8c 89       	ldd	r24, Y+20	; 0x14
 9fe:	9d 89       	ldd	r25, Y+21	; 0x15
 a00:	89 2b       	or	r24, r25
 a02:	19 f0       	breq	.+6      	; 0xa0a <vTaskIncrementTick+0x134>
 a04:	ce 01       	movw	r24, r28
 a06:	0c 96       	adiw	r24, 0x0c	; 12
 a08:	52 dc       	rcall	.-1884   	; 0x2ae <vListRemove>
 a0a:	8e 89       	ldd	r24, Y+22	; 0x16
 a0c:	90 91 f6 07 	lds	r25, 0x07F6	; 0x8007f6 <uxTopReadyPriority>
 a10:	98 17       	cp	r25, r24
 a12:	10 f4       	brcc	.+4      	; 0xa18 <vTaskIncrementTick+0x142>
 a14:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <uxTopReadyPriority>
 a18:	90 e0       	ldi	r25, 0x00	; 0
 a1a:	9c 01       	movw	r18, r24
 a1c:	22 0f       	add	r18, r18
 a1e:	33 1f       	adc	r19, r19
 a20:	22 0f       	add	r18, r18
 a22:	33 1f       	adc	r19, r19
 a24:	22 0f       	add	r18, r18
 a26:	33 1f       	adc	r19, r19
 a28:	82 0f       	add	r24, r18
 a2a:	93 1f       	adc	r25, r19
 a2c:	b8 01       	movw	r22, r16
 a2e:	86 5e       	subi	r24, 0xE6	; 230
 a30:	97 4f       	sbci	r25, 0xF7	; 247
 a32:	db db       	rcall	.-2122   	; 0x1ea <vListInsertEnd>
 a34:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxDelayedTaskList>
 a38:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxDelayedTaskList+0x1>
 a3c:	80 81       	ld	r24, Z
 a3e:	81 11       	cpse	r24, r1
 a40:	c1 cf       	rjmp	.-126    	; 0x9c4 <vTaskIncrementTick+0xee>
 a42:	b9 cf       	rjmp	.-142    	; 0x9b6 <vTaskIncrementTick+0xe0>
 a44:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <uxMissedTicks>
 a48:	8f 5f       	subi	r24, 0xFF	; 255
 a4a:	80 93 f3 07 	sts	0x07F3, r24	; 0x8007f3 <uxMissedTicks>
 a4e:	df 91       	pop	r29
 a50:	cf 91       	pop	r28
 a52:	1f 91       	pop	r17
 a54:	0f 91       	pop	r16
 a56:	08 95       	ret

00000a58 <xTaskResumeAll>:
 a58:	cf 92       	push	r12
 a5a:	df 92       	push	r13
 a5c:	ef 92       	push	r14
 a5e:	ff 92       	push	r15
 a60:	0f 93       	push	r16
 a62:	1f 93       	push	r17
 a64:	cf 93       	push	r28
 a66:	df 93       	push	r29
 a68:	0f b6       	in	r0, 0x3f	; 63
 a6a:	f8 94       	cli
 a6c:	0f 92       	push	r0
 a6e:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 a72:	81 50       	subi	r24, 0x01	; 1
 a74:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <uxSchedulerSuspended>
 a78:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 a7c:	81 11       	cpse	r24, r1
 a7e:	5f c0       	rjmp	.+190    	; 0xb3e <xTaskResumeAll+0xe6>
 a80:	80 91 fa 07 	lds	r24, 0x07FA	; 0x8007fa <uxCurrentNumberOfTasks>
 a84:	81 11       	cpse	r24, r1
 a86:	2f c0       	rjmp	.+94     	; 0xae6 <xTaskResumeAll+0x8e>
 a88:	5d c0       	rjmp	.+186    	; 0xb44 <xTaskResumeAll+0xec>
 a8a:	d7 01       	movw	r26, r14
 a8c:	15 96       	adiw	r26, 0x05	; 5
 a8e:	ed 91       	ld	r30, X+
 a90:	fc 91       	ld	r31, X
 a92:	16 97       	sbiw	r26, 0x06	; 6
 a94:	c6 81       	ldd	r28, Z+6	; 0x06
 a96:	d7 81       	ldd	r29, Z+7	; 0x07
 a98:	ce 01       	movw	r24, r28
 a9a:	0c 96       	adiw	r24, 0x0c	; 12
 a9c:	08 dc       	rcall	.-2032   	; 0x2ae <vListRemove>
 a9e:	8e 01       	movw	r16, r28
 aa0:	0e 5f       	subi	r16, 0xFE	; 254
 aa2:	1f 4f       	sbci	r17, 0xFF	; 255
 aa4:	c8 01       	movw	r24, r16
 aa6:	03 dc       	rcall	.-2042   	; 0x2ae <vListRemove>
 aa8:	8e 89       	ldd	r24, Y+22	; 0x16
 aaa:	90 91 f6 07 	lds	r25, 0x07F6	; 0x8007f6 <uxTopReadyPriority>
 aae:	98 17       	cp	r25, r24
 ab0:	10 f4       	brcc	.+4      	; 0xab6 <xTaskResumeAll+0x5e>
 ab2:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <uxTopReadyPriority>
 ab6:	90 e0       	ldi	r25, 0x00	; 0
 ab8:	9c 01       	movw	r18, r24
 aba:	22 0f       	add	r18, r18
 abc:	33 1f       	adc	r19, r19
 abe:	22 0f       	add	r18, r18
 ac0:	33 1f       	adc	r19, r19
 ac2:	22 0f       	add	r18, r18
 ac4:	33 1f       	adc	r19, r19
 ac6:	82 0f       	add	r24, r18
 ac8:	93 1f       	adc	r25, r19
 aca:	b8 01       	movw	r22, r16
 acc:	86 5e       	subi	r24, 0xE6	; 230
 ace:	97 4f       	sbci	r25, 0xF7	; 247
 ad0:	8c db       	rcall	.-2280   	; 0x1ea <vListInsertEnd>
 ad2:	e0 91 23 08 	lds	r30, 0x0823	; 0x800823 <pxCurrentTCB>
 ad6:	f0 91 24 08 	lds	r31, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 ada:	9e 89       	ldd	r25, Y+22	; 0x16
 adc:	86 89       	ldd	r24, Z+22	; 0x16
 ade:	98 17       	cp	r25, r24
 ae0:	58 f0       	brcs	.+22     	; 0xaf8 <xTaskResumeAll+0xa0>
 ae2:	dc 2c       	mov	r13, r12
 ae4:	09 c0       	rjmp	.+18     	; 0xaf8 <xTaskResumeAll+0xa0>
 ae6:	d1 2c       	mov	r13, r1
 ae8:	0f 2e       	mov	r0, r31
 aea:	fb ef       	ldi	r31, 0xFB	; 251
 aec:	ef 2e       	mov	r14, r31
 aee:	f7 e0       	ldi	r31, 0x07	; 7
 af0:	ff 2e       	mov	r15, r31
 af2:	f0 2d       	mov	r31, r0
 af4:	cc 24       	eor	r12, r12
 af6:	c3 94       	inc	r12
 af8:	f7 01       	movw	r30, r14
 afa:	80 81       	ld	r24, Z
 afc:	81 11       	cpse	r24, r1
 afe:	c5 cf       	rjmp	.-118    	; 0xa8a <xTaskResumeAll+0x32>
 b00:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <uxMissedTicks>
 b04:	88 23       	and	r24, r24
 b06:	79 f0       	breq	.+30     	; 0xb26 <xTaskResumeAll+0xce>
 b08:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <uxMissedTicks>
 b0c:	88 23       	and	r24, r24
 b0e:	91 f0       	breq	.+36     	; 0xb34 <xTaskResumeAll+0xdc>
 b10:	e2 de       	rcall	.-572    	; 0x8d6 <vTaskIncrementTick>
 b12:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <uxMissedTicks>
 b16:	81 50       	subi	r24, 0x01	; 1
 b18:	80 93 f3 07 	sts	0x07F3, r24	; 0x8007f3 <uxMissedTicks>
 b1c:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <uxMissedTicks>
 b20:	81 11       	cpse	r24, r1
 b22:	f6 cf       	rjmp	.-20     	; 0xb10 <xTaskResumeAll+0xb8>
 b24:	07 c0       	rjmp	.+14     	; 0xb34 <xTaskResumeAll+0xdc>
 b26:	f1 e0       	ldi	r31, 0x01	; 1
 b28:	df 16       	cp	r13, r31
 b2a:	21 f0       	breq	.+8      	; 0xb34 <xTaskResumeAll+0xdc>
 b2c:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <xMissedYield>
 b30:	81 30       	cpi	r24, 0x01	; 1
 b32:	39 f4       	brne	.+14     	; 0xb42 <xTaskResumeAll+0xea>
 b34:	10 92 f2 07 	sts	0x07F2, r1	; 0x8007f2 <xMissedYield>
 b38:	90 dc       	rcall	.-1760   	; 0x45a <vPortYield>
 b3a:	81 e0       	ldi	r24, 0x01	; 1
 b3c:	03 c0       	rjmp	.+6      	; 0xb44 <xTaskResumeAll+0xec>
 b3e:	80 e0       	ldi	r24, 0x00	; 0
 b40:	01 c0       	rjmp	.+2      	; 0xb44 <xTaskResumeAll+0xec>
 b42:	80 e0       	ldi	r24, 0x00	; 0
 b44:	0f 90       	pop	r0
 b46:	0f be       	out	0x3f, r0	; 63
 b48:	df 91       	pop	r29
 b4a:	cf 91       	pop	r28
 b4c:	1f 91       	pop	r17
 b4e:	0f 91       	pop	r16
 b50:	ff 90       	pop	r15
 b52:	ef 90       	pop	r14
 b54:	df 90       	pop	r13
 b56:	cf 90       	pop	r12
 b58:	08 95       	ret

00000b5a <vTaskDelayUntil>:
 b5a:	0f 93       	push	r16
 b5c:	1f 93       	push	r17
 b5e:	cf 93       	push	r28
 b60:	df 93       	push	r29
 b62:	8c 01       	movw	r16, r24
 b64:	eb 01       	movw	r28, r22
 b66:	a7 de       	rcall	.-690    	; 0x8b6 <vTaskSuspendAll>
 b68:	f8 01       	movw	r30, r16
 b6a:	80 81       	ld	r24, Z
 b6c:	91 81       	ldd	r25, Z+1	; 0x01
 b6e:	c8 0f       	add	r28, r24
 b70:	d9 1f       	adc	r29, r25
 b72:	20 91 f8 07 	lds	r18, 0x07F8	; 0x8007f8 <xTickCount>
 b76:	30 91 f9 07 	lds	r19, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 b7a:	28 17       	cp	r18, r24
 b7c:	39 07       	cpc	r19, r25
 b7e:	68 f4       	brcc	.+26     	; 0xb9a <vTaskDelayUntil+0x40>
 b80:	c8 17       	cp	r28, r24
 b82:	d9 07       	cpc	r29, r25
 b84:	30 f5       	brcc	.+76     	; 0xbd2 <vTaskDelayUntil+0x78>
 b86:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTickCount>
 b8a:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 b8e:	d1 83       	std	Z+1, r29	; 0x01
 b90:	c0 83       	st	Z, r28
 b92:	8c 17       	cp	r24, r28
 b94:	9d 07       	cpc	r25, r29
 b96:	a0 f4       	brcc	.+40     	; 0xbc0 <vTaskDelayUntil+0x66>
 b98:	0b c0       	rjmp	.+22     	; 0xbb0 <vTaskDelayUntil+0x56>
 b9a:	c8 17       	cp	r28, r24
 b9c:	d9 07       	cpc	r29, r25
 b9e:	a8 f0       	brcs	.+42     	; 0xbca <vTaskDelayUntil+0x70>
 ba0:	80 91 f8 07 	lds	r24, 0x07F8	; 0x8007f8 <xTickCount>
 ba4:	90 91 f9 07 	lds	r25, 0x07F9	; 0x8007f9 <xTickCount+0x1>
 ba8:	8c 17       	cp	r24, r28
 baa:	9d 07       	cpc	r25, r29
 bac:	70 f0       	brcs	.+28     	; 0xbca <vTaskDelayUntil+0x70>
 bae:	11 c0       	rjmp	.+34     	; 0xbd2 <vTaskDelayUntil+0x78>
 bb0:	80 91 23 08 	lds	r24, 0x0823	; 0x800823 <pxCurrentTCB>
 bb4:	90 91 24 08 	lds	r25, 0x0824	; 0x800824 <pxCurrentTCB+0x1>
 bb8:	02 96       	adiw	r24, 0x02	; 2
 bba:	79 db       	rcall	.-2318   	; 0x2ae <vListRemove>
 bbc:	ce 01       	movw	r24, r28
 bbe:	3c dd       	rcall	.-1416   	; 0x638 <prvAddCurrentTaskToDelayedList>
 bc0:	4b df       	rcall	.-362    	; 0xa58 <xTaskResumeAll>
 bc2:	81 11       	cpse	r24, r1
 bc4:	0a c0       	rjmp	.+20     	; 0xbda <vTaskDelayUntil+0x80>
 bc6:	49 dc       	rcall	.-1902   	; 0x45a <vPortYield>
 bc8:	08 c0       	rjmp	.+16     	; 0xbda <vTaskDelayUntil+0x80>
 bca:	f8 01       	movw	r30, r16
 bcc:	d1 83       	std	Z+1, r29	; 0x01
 bce:	c0 83       	st	Z, r28
 bd0:	ef cf       	rjmp	.-34     	; 0xbb0 <vTaskDelayUntil+0x56>
 bd2:	f8 01       	movw	r30, r16
 bd4:	d1 83       	std	Z+1, r29	; 0x01
 bd6:	c0 83       	st	Z, r28
 bd8:	f3 cf       	rjmp	.-26     	; 0xbc0 <vTaskDelayUntil+0x66>
 bda:	df 91       	pop	r29
 bdc:	cf 91       	pop	r28
 bde:	1f 91       	pop	r17
 be0:	0f 91       	pop	r16
 be2:	08 95       	ret

00000be4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 be4:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <uxSchedulerSuspended>
 be8:	81 11       	cpse	r24, r1
 bea:	13 c0       	rjmp	.+38     	; 0xc12 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bec:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <uxTopReadyPriority>
 bf0:	90 e0       	ldi	r25, 0x00	; 0
 bf2:	fc 01       	movw	r30, r24
 bf4:	ee 0f       	add	r30, r30
 bf6:	ff 1f       	adc	r31, r31
 bf8:	ee 0f       	add	r30, r30
 bfa:	ff 1f       	adc	r31, r31
 bfc:	ee 0f       	add	r30, r30
 bfe:	ff 1f       	adc	r31, r31
 c00:	8e 0f       	add	r24, r30
 c02:	9f 1f       	adc	r25, r31
 c04:	fc 01       	movw	r30, r24
 c06:	e6 5e       	subi	r30, 0xE6	; 230
 c08:	f7 4f       	sbci	r31, 0xF7	; 247
 c0a:	80 81       	ld	r24, Z
 c0c:	88 23       	and	r24, r24
 c0e:	29 f0       	breq	.+10     	; 0xc1a <vTaskSwitchContext+0x36>
 c10:	1b c0       	rjmp	.+54     	; 0xc48 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 c12:	81 e0       	ldi	r24, 0x01	; 1
 c14:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <xMissedYield>
 c18:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 c1a:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <uxTopReadyPriority>
 c1e:	81 50       	subi	r24, 0x01	; 1
 c20:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 c24:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <uxTopReadyPriority>
 c28:	90 e0       	ldi	r25, 0x00	; 0
 c2a:	fc 01       	movw	r30, r24
 c2c:	ee 0f       	add	r30, r30
 c2e:	ff 1f       	adc	r31, r31
 c30:	ee 0f       	add	r30, r30
 c32:	ff 1f       	adc	r31, r31
 c34:	ee 0f       	add	r30, r30
 c36:	ff 1f       	adc	r31, r31
 c38:	8e 0f       	add	r24, r30
 c3a:	9f 1f       	adc	r25, r31
 c3c:	fc 01       	movw	r30, r24
 c3e:	e6 5e       	subi	r30, 0xE6	; 230
 c40:	f7 4f       	sbci	r31, 0xF7	; 247
 c42:	80 81       	ld	r24, Z
 c44:	88 23       	and	r24, r24
 c46:	49 f3       	breq	.-46     	; 0xc1a <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 c48:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <uxTopReadyPriority>
 c4c:	90 e0       	ldi	r25, 0x00	; 0
 c4e:	9c 01       	movw	r18, r24
 c50:	22 0f       	add	r18, r18
 c52:	33 1f       	adc	r19, r19
 c54:	22 0f       	add	r18, r18
 c56:	33 1f       	adc	r19, r19
 c58:	22 0f       	add	r18, r18
 c5a:	33 1f       	adc	r19, r19
 c5c:	28 0f       	add	r18, r24
 c5e:	39 1f       	adc	r19, r25
 c60:	d9 01       	movw	r26, r18
 c62:	a6 5e       	subi	r26, 0xE6	; 230
 c64:	b7 4f       	sbci	r27, 0xF7	; 247
 c66:	11 96       	adiw	r26, 0x01	; 1
 c68:	ed 91       	ld	r30, X+
 c6a:	fc 91       	ld	r31, X
 c6c:	12 97       	sbiw	r26, 0x02	; 2
 c6e:	02 80       	ldd	r0, Z+2	; 0x02
 c70:	f3 81       	ldd	r31, Z+3	; 0x03
 c72:	e0 2d       	mov	r30, r0
 c74:	12 96       	adiw	r26, 0x02	; 2
 c76:	fc 93       	st	X, r31
 c78:	ee 93       	st	-X, r30
 c7a:	11 97       	sbiw	r26, 0x01	; 1
 c7c:	23 5e       	subi	r18, 0xE3	; 227
 c7e:	37 4f       	sbci	r19, 0xF7	; 247
 c80:	e2 17       	cp	r30, r18
 c82:	f3 07       	cpc	r31, r19
 c84:	29 f4       	brne	.+10     	; 0xc90 <vTaskSwitchContext+0xac>
 c86:	22 81       	ldd	r18, Z+2	; 0x02
 c88:	33 81       	ldd	r19, Z+3	; 0x03
 c8a:	fd 01       	movw	r30, r26
 c8c:	32 83       	std	Z+2, r19	; 0x02
 c8e:	21 83       	std	Z+1, r18	; 0x01
 c90:	fc 01       	movw	r30, r24
 c92:	ee 0f       	add	r30, r30
 c94:	ff 1f       	adc	r31, r31
 c96:	ee 0f       	add	r30, r30
 c98:	ff 1f       	adc	r31, r31
 c9a:	ee 0f       	add	r30, r30
 c9c:	ff 1f       	adc	r31, r31
 c9e:	8e 0f       	add	r24, r30
 ca0:	9f 1f       	adc	r25, r31
 ca2:	fc 01       	movw	r30, r24
 ca4:	e6 5e       	subi	r30, 0xE6	; 230
 ca6:	f7 4f       	sbci	r31, 0xF7	; 247
 ca8:	01 80       	ldd	r0, Z+1	; 0x01
 caa:	f2 81       	ldd	r31, Z+2	; 0x02
 cac:	e0 2d       	mov	r30, r0
 cae:	86 81       	ldd	r24, Z+6	; 0x06
 cb0:	97 81       	ldd	r25, Z+7	; 0x07
 cb2:	90 93 24 08 	sts	0x0824, r25	; 0x800824 <pxCurrentTCB+0x1>
 cb6:	80 93 23 08 	sts	0x0823, r24	; 0x800823 <pxCurrentTCB>
 cba:	08 95       	ret

00000cbc <memset>:
 cbc:	dc 01       	movw	r26, r24
 cbe:	01 c0       	rjmp	.+2      	; 0xcc2 <memset+0x6>
 cc0:	6d 93       	st	X+, r22
 cc2:	41 50       	subi	r20, 0x01	; 1
 cc4:	50 40       	sbci	r21, 0x00	; 0
 cc6:	e0 f7       	brcc	.-8      	; 0xcc0 <memset+0x4>
 cc8:	08 95       	ret

00000cca <strncpy>:
 cca:	fb 01       	movw	r30, r22
 ccc:	dc 01       	movw	r26, r24
 cce:	41 50       	subi	r20, 0x01	; 1
 cd0:	50 40       	sbci	r21, 0x00	; 0
 cd2:	48 f0       	brcs	.+18     	; 0xce6 <strncpy+0x1c>
 cd4:	01 90       	ld	r0, Z+
 cd6:	0d 92       	st	X+, r0
 cd8:	00 20       	and	r0, r0
 cda:	c9 f7       	brne	.-14     	; 0xcce <strncpy+0x4>
 cdc:	01 c0       	rjmp	.+2      	; 0xce0 <strncpy+0x16>
 cde:	1d 92       	st	X+, r1
 ce0:	41 50       	subi	r20, 0x01	; 1
 ce2:	50 40       	sbci	r21, 0x00	; 0
 ce4:	e0 f7       	brcc	.-8      	; 0xcde <strncpy+0x14>
 ce6:	08 95       	ret

00000ce8 <_exit>:
 ce8:	f8 94       	cli

00000cea <__stop_program>:
 cea:	ff cf       	rjmp	.-2      	; 0xcea <__stop_program>
